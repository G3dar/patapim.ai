---
export const prerender = false;
---
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>PATAPIM Remote</title>
  <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet" />
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@xterm/xterm@5.5.0/css/xterm.min.css" />
  <style is:inline>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    :root {
      --bg: #0a0a0b;
      --bg-surface: #131316;
      --bg-elevated: #1a1a1f;
      --border: #2a2a30;
      --border-active: #c9a227;
      --text: #e4e4e7;
      --text-dim: #71717a;
      --text-muted: #52525b;
      --accent: #c9a227;
      --accent-dim: rgba(201, 162, 39, 0.15);
      --success: #7cb382;
      --success-dim: rgba(124, 179, 130, 0.12);
      --error: #d47878;
      --radius: 8px;
    }

    html, body {
      height: 100%;
      background: var(--bg);
      color: var(--text);
      font-family: 'JetBrains Mono', monospace;
      overflow: hidden;
    }

    /* Full-page layout */
    .app {
      display: flex;
      flex-direction: column;
      height: 100vh;
      height: 100dvh;
    }

    /* Top bar */
    .topbar {
      display: flex;
      align-items: center;
      justify-content: space-between;
      height: 40px;
      padding: 0 12px;
      background: var(--bg-surface);
      border-bottom: 1px solid var(--border);
      flex-shrink: 0;
      z-index: 20;
    }

    .topbar-left {
      display: flex;
      align-items: center;
      gap: 10px;
      min-width: 0;
    }

    .topbar-logo {
      font-size: 13px;
      font-weight: 600;
      color: var(--accent);
      text-decoration: none;
      flex-shrink: 0;
    }

    .topbar-status {
      font-size: 11px;
      padding: 2px 8px;
      border-radius: 100px;
      font-weight: 500;
      flex-shrink: 0;
    }

    .topbar-status.connecting {
      background: var(--accent-dim);
      color: var(--accent);
    }

    .topbar-status.connected {
      background: var(--success-dim);
      color: var(--success);
    }

    .topbar-status.disconnected {
      background: rgba(212, 120, 120, 0.12);
      color: var(--error);
    }

    #sidebar-toggle {
      display: none;
      background: none;
      border: 1px solid var(--border);
      color: var(--text-dim);
      font-size: 16px;
      width: 30px;
      height: 26px;
      border-radius: 5px;
      cursor: pointer;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
      line-height: 1;
    }

    #sidebar-toggle:hover { color: var(--text); border-color: var(--text-dim); }

    #topbar-project {
      display: none;
      font-size: 12px;
      color: var(--text-dim);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: 140px;
    }

    .topbar-right {
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .topbar-btn {
      background: none;
      border: 1px solid var(--border);
      color: var(--text-dim);
      font-size: 12px;
      font-family: inherit;
      padding: 4px 10px;
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.15s;
    }

    .topbar-btn:hover {
      color: var(--text);
      border-color: var(--text-dim);
    }

    /* Content area: sidebar + main */
    .content-area {
      display: flex;
      flex: 1;
      overflow: hidden;
    }

    /* Sidebar */
    .sidebar {
      width: 220px;
      flex-shrink: 0;
      display: flex;
      flex-direction: column;
      background: var(--bg-surface);
      border-right: 1px solid var(--border);
      overflow: hidden;
    }

    .sidebar-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 10px 12px 8px;
      flex-shrink: 0;
    }

    .sidebar-header span {
      color: var(--text-muted);
      font-size: 10px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.8px;
    }

    #sidebar-close {
      display: none;
      background: none;
      border: none;
      color: var(--text-muted);
      font-size: 16px;
      cursor: pointer;
      padding: 2px;
      line-height: 1;
    }

    #sidebar-close:hover { color: var(--text); }

    /* Projects list */
    #projects-list {
      flex: 1;
      overflow-y: auto;
      padding: 0 8px;
      scrollbar-width: thin;
      scrollbar-color: var(--border) transparent;
    }

    .project-item {
      padding: 7px 10px;
      cursor: pointer;
      display: flex;
      align-items: center;
      border-radius: 6px;
      margin-bottom: 2px;
      color: var(--text-dim);
      transition: all 0.15s;
      border: 1px solid transparent;
    }

    .project-item:hover {
      background: var(--bg-elevated);
      color: var(--text);
    }

    .project-item.active {
      background: var(--accent-dim);
      color: var(--accent);
      border-color: var(--accent);
    }

    .project-icon {
      margin-right: 8px;
      font-size: 13px;
      opacity: 0.7;
      flex-shrink: 0;
    }

    .project-name {
      flex: 1;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      font-size: 12px;
      font-weight: 500;
    }

    .project-badges {
      display: flex;
      gap: 3px;
      margin-left: auto;
      flex-shrink: 0;
    }

    .tbadge {
      font-size: 10px;
      font-weight: 600;
      min-width: 16px;
      height: 16px;
      line-height: 16px;
      text-align: center;
      border-radius: 8px;
      padding: 0 4px;
    }

    .tbadge.attention {
      background: rgba(124, 179, 130, 0.18);
      color: var(--success);
    }

    .tbadge.busy {
      background: rgba(212, 120, 120, 0.18);
      color: var(--error);
    }

    .tbadge.idle {
      background: var(--bg-elevated);
      color: var(--text-muted);
    }

    .no-projects {
      color: var(--text-muted);
      font-size: 11px;
      padding: 16px 10px;
      text-align: center;
      font-style: italic;
    }

    /* Sidebar actions */
    .sidebar-actions {
      flex-shrink: 0;
      padding: 8px;
      border-top: 1px solid var(--border);
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .sidebar-btn {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
      padding: 7px 10px;
      border-radius: 6px;
      font-size: 11px;
      font-family: inherit;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.15s;
      border: 1px solid;
      white-space: nowrap;
    }

    .sidebar-btn:disabled {
      opacity: 0.5;
      cursor: default;
    }

    .btn-claude {
      background: rgba(124, 179, 130, 0.1);
      border-color: rgba(124, 179, 130, 0.3);
      color: var(--success);
    }

    .btn-claude:hover:not(:disabled) {
      background: rgba(124, 179, 130, 0.18);
      border-color: var(--success);
    }

    .sidebar-btn-row {
      display: flex;
      gap: 4px;
    }
    .sidebar-btn-row .sidebar-btn {
      flex: 1;
      font-size: 11px;
      padding: 5px 6px;
    }

    .btn-gemini {
      background: rgba(239, 68, 68, 0.08);
      border-color: rgba(239, 68, 68, 0.25);
      color: #ef4444;
    }
    .btn-gemini:hover:not(:disabled) {
      background: rgba(239, 68, 68, 0.15);
      border-color: #ef4444;
    }

    .btn-codex {
      background: rgba(96, 165, 250, 0.08);
      border-color: rgba(96, 165, 250, 0.25);
      color: #60a5fa;
    }
    .btn-codex:hover:not(:disabled) {
      background: rgba(96, 165, 250, 0.15);
      border-color: #60a5fa;
    }

    .btn-new-term {
      background: var(--bg-elevated);
      border-color: var(--border);
      color: var(--text-dim);
    }

    .btn-new-term:hover:not(:disabled) {
      color: var(--text);
      border-color: var(--text-dim);
    }

    /* Sidebar overlay (mobile) */
    #sidebar-overlay {
      display: none;
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.5);
      z-index: 29;
    }

    #sidebar-overlay.visible { display: block; }

    /* Main area */
    .main-area {
      display: flex;
      flex-direction: column;
      flex: 1;
      min-width: 0;
    }

    /* Terminal tabs */
    .tabs-bar {
      display: flex;
      align-items: center;
      height: 34px;
      padding: 0 6px;
      gap: 2px;
      background: var(--bg);
      border-bottom: 1px solid var(--border);
      overflow-x: auto;
      scrollbar-width: none;
      flex-shrink: 0;
    }

    .tabs-bar::-webkit-scrollbar { display: none; }

    .tab {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 0 10px;
      height: 26px;
      font-size: 11px;
      color: var(--text-dim);
      cursor: pointer;
      border-radius: 4px;
      white-space: nowrap;
      transition: all 0.15s;
      flex-shrink: 0;
      border: 1px solid transparent;
    }

    .tab:hover {
      color: var(--text);
      background: var(--bg-elevated);
    }

    .tab.active {
      color: var(--accent);
      background: var(--accent-dim);
      border-color: rgba(201, 162, 39, 0.25);
    }

    .tab-add {
      display: flex;
      align-items: center;
      justify-content: center;
      width: 26px;
      height: 26px;
      font-size: 14px;
      color: var(--text-muted);
      cursor: pointer;
      border-radius: 4px;
      border: 1px solid transparent;
      background: none;
      font-family: inherit;
      transition: all 0.15s;
      flex-shrink: 0;
    }

    .tab-add:hover {
      color: var(--text);
      background: var(--bg-elevated);
      border-color: var(--border);
    }

    /* Terminal container */
    .terminal-wrap {
      flex: 1;
      position: relative;
      overflow-x: auto;
      overflow-y: hidden;
    }

    .terminal-wrap .xterm {
      height: 100%;
      padding: 4px 0 0 4px;
    }

    .terminal-wrap .xterm-viewport {
      scrollbar-width: thin;
      scrollbar-color: var(--border) transparent;
    }
    .terminal-wrap .xterm-viewport::-webkit-scrollbar {
      width: 8px;
    }
    .terminal-wrap .xterm-viewport::-webkit-scrollbar-track {
      background: transparent;
    }
    .terminal-wrap .xterm-viewport::-webkit-scrollbar-thumb {
      background: var(--border);
      border-radius: 4px;
    }
    .terminal-wrap .xterm-viewport::-webkit-scrollbar-thumb:hover {
      background: var(--text-dim);
    }

    /* Special keys toolbar (mobile) */
    .keys-bar {
      display: none;
      align-items: center;
      height: 36px;
      padding: 0 8px;
      gap: 4px;
      background: var(--bg-surface);
      border-top: 1px solid var(--border);
      overflow-x: auto;
      scrollbar-width: none;
      flex-shrink: 0;
    }

    .keys-bar::-webkit-scrollbar { display: none; }

    .key-btn {
      background: var(--bg-elevated);
      border: 1px solid var(--border);
      color: var(--text-dim);
      font-size: 11px;
      font-family: inherit;
      padding: 4px 10px;
      border-radius: 5px;
      cursor: pointer;
      white-space: nowrap;
      flex-shrink: 0;
      transition: all 0.15s;
    }

    .key-btn:hover, .key-btn:active {
      color: var(--text);
      border-color: var(--text-dim);
    }

    .key-btn.active {
      color: var(--accent);
      border-color: var(--accent);
      background: var(--accent-dim);
    }

    /* Scroll to bottom */
    .scroll-bottom {
      display: none;
      position: absolute;
      bottom: 16px;
      right: 16px;
      width: 36px;
      height: 36px;
      border-radius: 50%;
      background: var(--bg-elevated);
      border: 1px solid var(--border);
      color: var(--text-dim);
      cursor: pointer;
      align-items: center;
      justify-content: center;
      z-index: 10;
      transition: all 0.15s;
    }

    .scroll-bottom:hover {
      color: var(--text);
      border-color: var(--text-dim);
    }

    .scroll-bottom.visible { display: flex; }

    /* Loading screen */
    .loading-screen {
      position: absolute;
      inset: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background: var(--bg);
      z-index: 100;
      gap: 12px;
    }

    .loading-screen.hidden { display: none; }

    .loading-spinner {
      width: 32px;
      height: 32px;
      border: 3px solid var(--border);
      border-top-color: var(--accent);
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
    }

    @keyframes spin { to { transform: rotate(360deg); } }

    .loading-text {
      font-size: 13px;
      color: var(--text-dim);
    }

    .loading-error {
      font-size: 13px;
      color: var(--error);
      text-align: center;
      max-width: 320px;
      line-height: 1.5;
    }

    .loading-error a {
      color: var(--accent);
      text-decoration: none;
    }

    /* Mobile responsive */
    @media (max-width: 768px) {
      .keys-bar { display: flex; }

      #sidebar-toggle { display: flex; }
      #topbar-project { display: block; }
      #sidebar-close { display: block; }

      .sidebar {
        position: fixed;
        top: 40px;
        left: 0;
        bottom: 0;
        z-index: 30;
        width: 260px;
        transform: translateX(-100%);
        transition: transform 0.2s ease;
      }

      .sidebar.open {
        transform: translateX(0);
      }

      /* Hide font size buttons on mobile to save space */
      #btn-font-dec, #btn-font-inc { display: none; }
    }
  </style>
</head>
<body>
  <div class="app">
    <div class="topbar">
      <div class="topbar-left">
        <button id="sidebar-toggle" title="Toggle projects">&#9776;</button>
        <a href="/go" class="topbar-logo">PATAPIM</a>
        <span id="topbar-project"></span>
        <span class="topbar-status connecting" id="status">Connecting...</span>
      </div>
      <div class="topbar-right">
        <button class="topbar-btn" id="btn-font-dec" title="Decrease font">A-</button>
        <button class="topbar-btn" id="btn-font-inc" title="Increase font">A+</button>
        <button class="topbar-btn" id="btn-disconnect" title="Disconnect">Disconnect</button>
      </div>
    </div>

    <div id="sidebar-overlay"></div>

    <div class="content-area">
      <div class="sidebar" id="sidebar">
        <div class="sidebar-header">
          <span>Projects</span>
          <button id="sidebar-close">&times;</button>
        </div>
        <div id="projects-list">
          <div class="no-projects">Connecting...</div>
        </div>
        <div class="sidebar-actions">
          <button class="sidebar-btn btn-claude" id="btn-start-claude" disabled>
            <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><polygon points="5 3 19 12 5 21 5 3"></polygon></svg>
            Start Claude Code
          </button>
          <div class="sidebar-btn-row">
            <button class="sidebar-btn btn-gemini" id="btn-start-gemini" disabled>Start Gemini</button>
            <button class="sidebar-btn btn-codex" id="btn-start-codex" disabled>Start Codex</button>
          </div>
          <button class="sidebar-btn btn-new-term" id="btn-new-terminal" disabled>
            + New Terminal
          </button>
        </div>
      </div>

      <div class="main-area">
        <div class="tabs-bar" id="tabs"></div>

        <div class="terminal-wrap" id="terminal-wrap">
          <div class="loading-screen" id="loading">
            <div class="loading-spinner"></div>
            <div class="loading-text" id="loading-text">Connecting to device...</div>
          </div>
          <button class="scroll-bottom" id="scroll-bottom" title="Scroll to bottom">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <polyline points="6 9 12 15 18 9"></polyline>
            </svg>
          </button>
        </div>

        <div class="keys-bar" id="keys-bar">
          <button class="key-btn" data-modifier="ctrl">Ctrl</button>
          <button class="key-btn" data-modifier="alt">Alt</button>
          <button class="key-btn" data-key="Tab">Tab</button>
          <button class="key-btn" data-key="Escape">Esc</button>
          <button class="key-btn" data-key="ArrowUp">&uarr;</button>
          <button class="key-btn" data-key="ArrowDown">&darr;</button>
          <button class="key-btn" data-key="ArrowLeft">&larr;</button>
          <button class="key-btn" data-key="ArrowRight">&rarr;</button>
          <button class="key-btn" data-seq="\x01">^A</button>
          <button class="key-btn" data-seq="\x03">^C</button>
          <button class="key-btn" data-seq="\x04">^D</button>
          <button class="key-btn" data-seq="\x0c">^L</button>
          <button class="key-btn" data-seq="\x1a">^Z</button>
        </div>
      </div>
    </div>
  </div>

  <script is:inline type="module">
    import { Terminal } from 'https://cdn.jsdelivr.net/npm/@xterm/xterm@5.5.0/+esm';
    import { FitAddon } from 'https://cdn.jsdelivr.net/npm/@xterm/addon-fit@0.10.0/+esm';

    // Parse URL params
    const params = new URLSearchParams(location.search);
    const connectToken = params.get('t');
    const tunnelUrl = params.get('url');

    // DOM
    const statusEl = document.getElementById('status');
    const tabsEl = document.getElementById('tabs');
    const loadingEl = document.getElementById('loading');
    const loadingText = document.getElementById('loading-text');
    const terminalWrap = document.getElementById('terminal-wrap');
    const scrollBottomBtn = document.getElementById('scroll-bottom');
    const sidebarEl = document.getElementById('sidebar');
    const sidebarOverlay = document.getElementById('sidebar-overlay');
    const sidebarToggle = document.getElementById('sidebar-toggle');
    const sidebarClose = document.getElementById('sidebar-close');
    const projectsList = document.getElementById('projects-list');
    const topbarProject = document.getElementById('topbar-project');
    const btnStartClaude = document.getElementById('btn-start-claude');
    const btnStartGemini = document.getElementById('btn-start-gemini');
    const btnStartCodex = document.getElementById('btn-start-codex');
    const btnNewTerminal = document.getElementById('btn-new-terminal');

    // State
    let ws = null;
    let term = null;
    let fitAddon = null;
    let currentTerminalId = null;
    let terminals = [];
    let isSwitching = false;
    let switchOutputQueue = [];
    let ptyDims = null;
    let fontSize = 14;
    let reconnectAttempts = 0;
    let reconnectTimer = null;
    let isAuthenticated = false;
    const modifiers = { ctrl: false, alt: false };

    // Sidebar state
    let sidebarData = { projects: [], currentProject: null };

    // Validate params
    if (!connectToken || !tunnelUrl) {
      showError('Missing connection parameters. <a href="/go">Go back to dashboard</a>');
    } else {
      initTerminal();
      connect();
    }

    function showError(html) {
      loadingText.remove();
      const spinner = loadingEl.querySelector('.loading-spinner');
      if (spinner) spinner.remove();
      const err = document.createElement('div');
      err.className = 'loading-error';
      err.innerHTML = html;
      loadingEl.appendChild(err);
    }

    function setStatus(state, text) {
      statusEl.textContent = text;
      statusEl.className = 'topbar-status ' + state;
    }

    // Apply PTY cols but fit rows to container height.
    // Uses proposeDimensions() to avoid double reflow (fit→resize would reflow buffer twice).
    function applyPtyDims() {
      if (!ptyDims || !fitAddon || !term) return;
      const dims = fitAddon.proposeDimensions();
      if (dims) {
        term.resize(ptyDims.cols, dims.rows);
      }
    }

    function initTerminal() {
      term = new Terminal({
        fontFamily: "'JetBrains Mono', monospace",
        fontSize,
        theme: {
          background: '#0a0a0b',
          foreground: '#e4e4e7',
          cursor: '#c9a227',
          cursorAccent: '#0a0a0b',
          selectionBackground: 'rgba(201, 162, 39, 0.3)',
          black: '#27272a',
          red: '#d47878',
          green: '#7cb382',
          yellow: '#c9a227',
          blue: '#6b9bd2',
          magenta: '#b07eb5',
          cyan: '#6bbfb8',
          white: '#e4e4e7',
          brightBlack: '#52525b',
          brightRed: '#e89090',
          brightGreen: '#96c99b',
          brightYellow: '#d4b84a',
          brightBlue: '#87b3e0',
          brightMagenta: '#c89bcb',
          brightCyan: '#88d3cd',
          brightWhite: '#fafafa',
        },
        cursorBlink: true,
        scrollback: 5000,
        allowProposedApi: true,
      });

      fitAddon = new FitAddon();
      term.loadAddon(fitAddon);
      term.open(terminalWrap);
      fitAddon.fit();

      // Handle user input
      term.onData(data => {
        if (!ws || ws.readyState !== WebSocket.OPEN || !isAuthenticated) return;

        // Apply modifiers
        let sendData = data;
        if (modifiers.ctrl && data.length === 1) {
          const code = data.toUpperCase().charCodeAt(0) - 64;
          if (code > 0 && code < 32) {
            sendData = String.fromCharCode(code);
          }
          modifiers.ctrl = false;
          updateModifierButtons();
        }
        if (modifiers.alt) {
          sendData = '\x1b' + data;
          modifiers.alt = false;
          updateModifierButtons();
        }

        ws.send(JSON.stringify({
          type: 'input',
          terminalId: currentTerminalId,
          data: sendData,
        }));
      });

      // Track scroll position
      term.onScroll(() => {
        const buf = term.buffer.active;
        const atBottom = buf.viewportY >= buf.baseY;
        scrollBottomBtn.classList.toggle('visible', !atBottom);
      });

      // Mobile: enable 2D touch panning and cursor follow
      if (window.matchMedia('(max-width: 768px)').matches) {
        const xtermScreen = terminalWrap.querySelector('.xterm-screen');
        if (xtermScreen) xtermScreen.style.touchAction = 'none';

        const viewport = terminalWrap.querySelector('.xterm-viewport');
        if (viewport) {
          let lastX = 0, lastY = 0, lastTime = 0, vx = 0, vy = 0, mid = null, panning = false;
          const cancel = () => { if (mid) { cancelAnimationFrame(mid); mid = null; } };

          terminalWrap.addEventListener('touchstart', e => {
            cancel();
            if (e.touches.length === 1) {
              lastX = e.touches[0].clientX; lastY = e.touches[0].clientY;
              lastTime = Date.now(); vx = 0; vy = 0; panning = false;
            }
          }, { passive: true });

          terminalWrap.addEventListener('touchmove', e => {
            if (e.touches.length !== 1) return;
            const t = e.touches[0], dx = lastX - t.clientX, dy = lastY - t.clientY;
            if (!panning && (Math.abs(dx) > 5 || Math.abs(dy) > 5)) panning = true;
            if (panning) {
              const now = Date.now(), dt = now - lastTime;
              if (dt > 0) { vx = dx / dt; vy = dy / dt; }
              terminalWrap.scrollLeft += dx;
              viewport.scrollTop += dy;
              lastX = t.clientX; lastY = t.clientY; lastTime = now;
            }
          }, { passive: true });

          terminalWrap.addEventListener('touchend', () => {
            if (panning && (Math.abs(vx) > 0.3 || Math.abs(vy) > 0.3)) {
              let mx = vx * 16, my = vy * 16;
              const momentum = () => {
                if (Math.abs(mx) < 0.5 && Math.abs(my) < 0.5) { cancel(); return; }
                terminalWrap.scrollLeft += mx; viewport.scrollTop += my;
                mx *= 0.95; my *= 0.95;
                mid = requestAnimationFrame(momentum);
              };
              mid = requestAnimationFrame(momentum);
            }
            panning = false;
          }, { passive: true });
        }

        // Auto-scroll to keep cursor visible when typing
        let cursorFollowTimer = null;
        term.onData(() => {
          clearTimeout(cursorFollowTimer);
          cursorFollowTimer = setTimeout(() => {
            if (!xtermScreen) return;
            const charW = xtermScreen.offsetWidth / term.cols;
            const cursorPx = term.buffer.active.cursorX * charW;
            const sl = terminalWrap.scrollLeft, vw = terminalWrap.clientWidth, pad = charW * 3;
            if (cursorPx > sl + vw - pad) terminalWrap.scrollLeft = cursorPx - vw + pad;
            else if (cursorPx < sl + pad) terminalWrap.scrollLeft = Math.max(0, cursorPx - pad);
          }, 50);
        });
      }

      // Resize — delegates to applyPtyDims
      const ro = new ResizeObserver(() => {
        if (ptyDims && fitAddon) {
          applyPtyDims();
        } else if (fitAddon) {
          fitAddon.fit();
        }
      });
      ro.observe(terminalWrap);
    }

    function connect() {
      if (!tunnelUrl) return;

      // Build WebSocket URL from tunnel URL
      const wsUrl = tunnelUrl.replace(/^https?:/, 'wss:');
      setStatus('connecting', 'Connecting...');
      loadingText && (loadingText.textContent = 'Connecting to device...');

      try {
        ws = new WebSocket(wsUrl);
      } catch (e) {
        showError('Failed to connect. <a href="/go">Go back</a>');
        return;
      }

      ws.onopen = () => {
        setStatus('connecting', 'Authenticating...');
        loadingText && (loadingText.textContent = 'Authenticating...');
        reconnectAttempts = 0;
        // Auth is sent after receiving 'welcome' message to avoid double-auth
      };

      ws.onmessage = (e) => {
        try {
          handleMessage(JSON.parse(e.data));
        } catch (err) {
          console.error('[WS] Parse error:', err);
        }
      };

      ws.onclose = () => {
        setStatus('disconnected', 'Disconnected');
        enableActions(false);
        if (isAuthenticated && reconnectAttempts < 10) {
          reconnectTimer = setTimeout(() => {
            reconnectAttempts++;
            connect();
          }, 2000);
        }
      };

      ws.onerror = () => {
        setStatus('disconnected', 'Connection error');
      };
    }

    function handleMessage(msg) {
      switch (msg.type) {
        case 'welcome':
          // Server sent welcome, now authenticate with connect token
          ws.send(JSON.stringify({
            type: 'auth',
            connectToken,
          }));
          break;

        case 'auth_result':
          if (msg.success) {
            isAuthenticated = true;
            setStatus('connected', 'Connected');
            loadingEl.classList.add('hidden');
            enableActions(true);

            // Clear URL params to prevent token reuse on refresh
            const cleanUrl = new URL(location.href);
            cleanUrl.searchParams.delete('t');
            history.replaceState(null, '', cleanUrl.toString());

            // Don't render tabs from auth_result — wait for sidebar_data + get_terminals
            // Request sidebar data first, which will trigger get_terminals with correct project
            ws.send(JSON.stringify({ type: 'get_sidebar_data' }));

            term.focus();
          } else {
            showError(
              'Authentication failed: ' + (msg.error || 'Unknown error') +
              '<br><br><a href="/go">Go back to dashboard</a>'
            );
          }
          break;

        case 'output':
          if (isSwitching) {
            switchOutputQueue.push(msg);
            break;
          }
          if (term && msg.terminalId === currentTerminalId) {
            term.write(msg.data);
          }
          break;

        case 'pty_dimensions':
          ptyDims = { cols: msg.cols, rows: msg.rows };
          applyPtyDims();
          break;

        case 'terminal_init':
          if (term && msg.terminalId === currentTerminalId) {
            if (msg.cols && msg.rows) {
              ptyDims = { cols: msg.cols, rows: msg.rows };
              applyPtyDims();
            }
            term.clear();
            if (msg.data) {
              term.write(msg.data);
            }
          }
          break;

        case 'terminals':
        case 'switched':
          if (msg.terminals) {
            terminals = msg.terminals;
            renderTabs();
          }
          if (msg.currentTerminal || msg.terminalId) {
            const newId = msg.currentTerminal || msg.terminalId;
            if (newId !== currentTerminalId && term) {
              term.clear();
            }
            currentTerminalId = newId;
            highlightTab(currentTerminalId);
          }
          if (msg.type === 'switched' && term) {
            if (msg.cols && msg.rows) {
              ptyDims = { cols: msg.cols, rows: msg.rows };
              applyPtyDims();
            }
            if (msg.buffer) {
              term.write(msg.buffer);
            }
            isSwitching = false;
            const queue = switchOutputQueue;
            switchOutputQueue = [];
            for (const q of queue) {
              if (q.terminalId === currentTerminalId && q.data) {
                term.write(q.data);
              }
            }
          }
          break;

        case 'terminal_created':
          ws.send(JSON.stringify({ type: 'get_terminals', projectPath: sidebarData.currentProject }));
          break;

        case 'terminal_closed':
          if (msg.terminalId === currentTerminalId) {
            currentTerminalId = null;
            term.clear();
          }
          ws.send(JSON.stringify({ type: 'get_terminals', projectPath: sidebarData.currentProject }));
          break;

        case 'sidebar_data':
          sidebarData.projects = msg.projects || [];
          sidebarData.currentProject = msg.currentProject || null;
          renderProjects();
          updateTopbarProject();
          // Fetch terminals with explicit project filter
          ws.send(JSON.stringify({ type: 'get_terminals', projectPath: sidebarData.currentProject }));
          break;

        case 'command_response':
          if (msg.success) {
            // Re-fetch terminals after successful command
            ws.send(JSON.stringify({ type: 'get_terminals', projectPath: sidebarData.currentProject }));
            ws.send(JSON.stringify({ type: 'get_sidebar_data' }));
          }
          break;

        case 'pong':
          break;
      }
    }

    // -- Sidebar: projects --

    function renderProjects() {
      projectsList.innerHTML = '';

      // Filter out archived, sort by lastOpenedAt
      const projects = (sidebarData.projects || [])
        .filter(p => !p.archived)
        .sort((a, b) => {
          const ta = a.lastOpenedAt || a.addedAt || '';
          const tb = b.lastOpenedAt || b.addedAt || '';
          return tb.localeCompare(ta);
        });

      if (projects.length === 0) {
        const empty = document.createElement('div');
        empty.className = 'no-projects';
        empty.textContent = 'No projects found';
        projectsList.appendChild(empty);
        return;
      }

      projects.forEach(p => {
        const item = document.createElement('div');
        item.className = 'project-item' + (p.path === sidebarData.currentProject ? ' active' : '');
        item.dataset.path = p.path;

        const icon = document.createElement('span');
        icon.className = 'project-icon';
        icon.textContent = '\uD83D\uDCC1';
        item.appendChild(icon);

        const name = document.createElement('span');
        name.className = 'project-name';
        name.textContent = p.path.split(/[/\\]/).filter(Boolean).pop() || p.path;
        name.title = p.path;
        item.appendChild(name);

        // Terminal count badges (attention=green/done, busy=red/processing, idle=grey)
        const counts = p.terminalCounts;
        if (counts && (counts.attention > 0 || counts.busy > 0 || counts.idle > 0)) {
          const badges = document.createElement('div');
          badges.className = 'project-badges';

          if (counts.attention > 0) {
            const b = document.createElement('span');
            b.className = 'tbadge attention';
            b.textContent = counts.attention;
            b.title = counts.attention + ' finished';
            badges.appendChild(b);
          }
          if (counts.busy > 0) {
            const b = document.createElement('span');
            b.className = 'tbadge busy';
            b.textContent = counts.busy;
            b.title = counts.busy + ' processing';
            badges.appendChild(b);
          }
          if (counts.idle > 0) {
            const b = document.createElement('span');
            b.className = 'tbadge idle';
            b.textContent = counts.idle;
            b.title = counts.idle + ' idle';
            badges.appendChild(b);
          }

          item.appendChild(badges);
        }

        item.addEventListener('click', () => selectProject(p.path));
        projectsList.appendChild(item);
      });
    }

    function selectProject(path) {
      if (!ws || ws.readyState !== WebSocket.OPEN) return;

      sidebarData.currentProject = path;
      renderProjects();
      updateTopbarProject();

      ws.send(JSON.stringify({ type: 'select_project', path }));
      ws.send(JSON.stringify({ type: 'get_terminals', projectPath: path }));

      // Close sidebar on mobile
      closeSidebar();

      term.focus();
    }

    function updateTopbarProject() {
      if (!sidebarData.currentProject) {
        topbarProject.textContent = '';
        return;
      }
      const name = sidebarData.currentProject.split(/[/\\]/).filter(Boolean).pop();
      topbarProject.textContent = name || '';
    }

    // -- Tabs --

    function extractTerminalNumber(id) {
      const match = id && id.match(/(\d+)/);
      return match ? match[1] : '?';
    }

    function renderTabs() {
      tabsEl.innerHTML = '';
      terminals.forEach((t, i) => {
        const tab = document.createElement('div');
        tab.className = 'tab' + (t.id === currentTerminalId ? ' active' : '');
        tab.dataset.terminalId = t.id;

        const label = document.createElement('span');
        label.textContent = t.name || ('Terminal ' + extractTerminalNumber(t.id));
        tab.appendChild(label);

        tab.addEventListener('click', () => switchTerminal(t.id));
        tabsEl.appendChild(tab);
      });

      // Add "+" button at end
      const addBtn = document.createElement('button');
      addBtn.className = 'tab-add';
      addBtn.textContent = '+';
      addBtn.title = 'New terminal';
      addBtn.addEventListener('click', () => {
        if (ws && ws.readyState === WebSocket.OPEN) {
          ws.send(JSON.stringify({ type: 'new_terminal' }));
        }
      });
      tabsEl.appendChild(addBtn);
    }

    function highlightTab(id) {
      tabsEl.querySelectorAll('.tab').forEach(tab => {
        tab.classList.toggle('active', tab.dataset.terminalId === id);
      });
    }

    function switchTerminal(id) {
      if (id === currentTerminalId || !ws || ws.readyState !== WebSocket.OPEN) return;
      isSwitching = true;
      switchOutputQueue = [];
      term.clear();
      ws.send(JSON.stringify({ type: 'switch', terminalId: id }));
    }

    // -- Sidebar toggle (mobile) --

    function openSidebar() {
      sidebarEl.classList.add('open');
      sidebarOverlay.classList.add('visible');
    }

    function closeSidebar() {
      sidebarEl.classList.remove('open');
      sidebarOverlay.classList.remove('visible');
    }

    sidebarToggle.addEventListener('click', () => {
      if (sidebarEl.classList.contains('open')) {
        closeSidebar();
      } else {
        openSidebar();
      }
    });

    sidebarClose.addEventListener('click', closeSidebar);
    sidebarOverlay.addEventListener('click', closeSidebar);

    // -- Action buttons --

    function enableActions(enabled) {
      btnStartClaude.disabled = !enabled;
      btnStartGemini.disabled = !enabled;
      btnStartCodex.disabled = !enabled;
      btnNewTerminal.disabled = !enabled;
    }

    // Send AI command to current terminal (same as desktop startAICommand)
    function sendAICommand(command) {
      if (!ws || ws.readyState !== WebSocket.OPEN || !currentTerminalId) return;
      ws.send(JSON.stringify({ type: 'input', terminalId: currentTerminalId, data: command + '\r' }));
    }

    btnStartClaude.addEventListener('click', () => {
      sendAICommand('claude --dangerously-skip-permissions');
    });

    btnStartGemini.addEventListener('click', () => {
      sendAICommand('gemini --yolo');
    });

    btnStartCodex.addEventListener('click', () => {
      sendAICommand('codex --dangerously-bypass-approvals-and-sandbox');
    });

    btnNewTerminal.addEventListener('click', () => {
      if (!ws || ws.readyState !== WebSocket.OPEN) return;
      ws.send(JSON.stringify({ type: 'new_terminal' }));
    });

    // -- Font size controls --

    document.getElementById('btn-font-dec').addEventListener('click', () => {
      fontSize = Math.max(8, fontSize - 1);
      term.options.fontSize = fontSize;
      if (ptyDims) applyPtyDims();
      else fitAddon.fit();
    });

    document.getElementById('btn-font-inc').addEventListener('click', () => {
      fontSize = Math.min(28, fontSize + 1);
      term.options.fontSize = fontSize;
      if (ptyDims) applyPtyDims();
      else fitAddon.fit();
    });

    // Disconnect
    document.getElementById('btn-disconnect').addEventListener('click', () => {
      isAuthenticated = false;
      if (reconnectTimer) clearTimeout(reconnectTimer);
      if (ws) ws.close();
      location.href = '/go';
    });

    // Scroll to bottom
    scrollBottomBtn.addEventListener('click', () => {
      term.scrollToBottom();
      scrollBottomBtn.classList.remove('visible');
    });

    // Special keys bar
    document.querySelectorAll('.key-btn[data-modifier]').forEach(btn => {
      btn.addEventListener('click', () => {
        const mod = btn.dataset.modifier;
        modifiers[mod] = !modifiers[mod];
        updateModifierButtons();
        term.focus();
      });
    });

    document.querySelectorAll('.key-btn[data-key]').forEach(btn => {
      btn.addEventListener('click', () => {
        if (!ws || ws.readyState !== WebSocket.OPEN) return;
        const key = btn.dataset.key;
        const keyMap = {
          Tab: '\t',
          Escape: '\x1b',
          ArrowUp: '\x1b[A',
          ArrowDown: '\x1b[B',
          ArrowRight: '\x1b[C',
          ArrowLeft: '\x1b[D',
        };
        const data = keyMap[key] || '';
        if (data) {
          ws.send(JSON.stringify({
            type: 'input',
            terminalId: currentTerminalId,
            data,
          }));
        }
        term.focus();
      });
    });

    document.querySelectorAll('.key-btn[data-seq]').forEach(btn => {
      btn.addEventListener('click', () => {
        if (!ws || ws.readyState !== WebSocket.OPEN) return;
        ws.send(JSON.stringify({
          type: 'input',
          terminalId: currentTerminalId,
          data: btn.dataset.seq,
        }));
        term.focus();
      });
    });

    function updateModifierButtons() {
      document.querySelectorAll('.key-btn[data-modifier]').forEach(btn => {
        const mod = btn.dataset.modifier;
        btn.classList.toggle('active', modifiers[mod]);
      });
    }

    // Keepalive ping
    setInterval(() => {
      if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({ type: 'ping' }));
      }
    }, 30000);
  </script>
</body>
</html>
