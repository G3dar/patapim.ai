---
export const prerender = false;
Astro.response.headers.set('Cache-Control', 'no-store, no-cache, must-revalidate, max-age=0');
Astro.response.headers.set('Pragma', 'no-cache');
Astro.response.headers.set('Expires', '0');
---
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>PATAPIM Remote</title>
  <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet" />
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@xterm/xterm@5.5.0/css/xterm.min.css" />
  <style is:inline>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    :root {
      --bg: #0a0a0b;
      --bg-surface: #131316;
      --bg-elevated: #1a1a1f;
      --border: #2a2a30;
      --border-active: #c9a227;
      --text: #e4e4e7;
      --text-dim: #71717a;
      --text-muted: #52525b;
      --accent: #c9a227;
      --accent-dim: rgba(201, 162, 39, 0.15);
      --success: #7cb382;
      --success-dim: rgba(124, 179, 130, 0.12);
      --error: #d47878;
      --radius: 8px;
    }

    html, body {
      height: 100%;
      background: var(--bg);
      color: var(--text);
      font-family: 'JetBrains Mono', monospace;
      overflow: hidden;
    }

    /* Full-page layout */
    .app {
      display: flex;
      flex-direction: column;
      height: 100vh;
      height: 100dvh;
    }

    /* Top bar */
    .topbar {
      display: flex;
      align-items: center;
      justify-content: space-between;
      height: 40px;
      padding: 0 12px;
      background: var(--bg-surface);
      border-bottom: 1px solid var(--border);
      flex-shrink: 0;
      z-index: 20;
    }

    .topbar-left {
      display: flex;
      align-items: center;
      gap: 10px;
      min-width: 0;
    }

    .topbar-logo {
      font-size: 13px;
      font-weight: 600;
      color: var(--accent);
      text-decoration: none;
      flex-shrink: 0;
    }

    .topbar-status {
      font-size: 11px;
      padding: 2px 8px;
      border-radius: 100px;
      font-weight: 500;
      flex-shrink: 0;
    }

    .topbar-status.connecting {
      background: var(--accent-dim);
      color: var(--accent);
    }

    .topbar-status.connected {
      background: var(--success-dim);
      color: var(--success);
    }

    .topbar-status.disconnected {
      background: rgba(212, 120, 120, 0.12);
      color: var(--error);
    }

    #sidebar-toggle {
      display: none;
      background: none;
      border: 1px solid var(--border);
      color: var(--text-dim);
      font-size: 16px;
      width: 30px;
      height: 26px;
      border-radius: 5px;
      cursor: pointer;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
      line-height: 1;
    }

    #sidebar-toggle:hover { color: var(--text); border-color: var(--text-dim); }

    #topbar-project {
      display: none;
      font-size: 12px;
      color: var(--text-dim);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: 140px;
    }

    .topbar-right {
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .topbar-btn {
      background: none;
      border: 1px solid var(--border);
      color: var(--text-dim);
      font-size: 12px;
      font-family: inherit;
      padding: 4px 10px;
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.15s;
    }

    .topbar-btn:hover {
      color: var(--text);
      border-color: var(--text-dim);
    }

    /* Content area: sidebar + main */
    .content-area {
      display: flex;
      flex: 1;
      overflow: hidden;
    }

    /* Sidebar */
    .sidebar {
      width: 220px;
      flex-shrink: 0;
      display: flex;
      flex-direction: column;
      background: var(--bg-surface);
      border-right: 1px solid var(--border);
      overflow: hidden;
    }

    .sidebar-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 10px 12px 8px;
      flex-shrink: 0;
    }

    .sidebar-header span {
      color: var(--text-muted);
      font-size: 10px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.8px;
    }

    #sidebar-close {
      display: none;
      background: none;
      border: none;
      color: var(--text-muted);
      font-size: 16px;
      cursor: pointer;
      padding: 2px;
      line-height: 1;
    }

    #sidebar-close:hover { color: var(--text); }

    /* Projects list */
    #projects-list {
      flex: 1;
      overflow-y: auto;
      padding: 0 8px;
      scrollbar-width: thin;
      scrollbar-color: var(--border) transparent;
    }

    .project-item {
      padding: 7px 10px;
      cursor: pointer;
      display: flex;
      align-items: center;
      border-radius: 6px;
      margin-bottom: 2px;
      color: var(--text-dim);
      transition: all 0.15s;
      border: 1px solid transparent;
    }

    .project-item:hover {
      background: var(--bg-elevated);
      color: var(--text);
    }

    .project-item.active {
      background: var(--accent-dim);
      color: var(--accent);
      border-color: var(--accent);
    }

    .project-icon {
      margin-right: 8px;
      font-size: 13px;
      opacity: 0.7;
      flex-shrink: 0;
    }

    .project-name {
      flex: 1;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      font-size: 12px;
      font-weight: 500;
    }

    .project-badges {
      display: flex;
      gap: 3px;
      margin-left: auto;
      flex-shrink: 0;
    }

    .tbadge {
      font-size: 10px;
      font-weight: 600;
      min-width: 16px;
      height: 16px;
      line-height: 16px;
      text-align: center;
      border-radius: 8px;
      padding: 0 4px;
    }

    .tbadge.attention {
      background: rgba(124, 179, 130, 0.18);
      color: var(--success);
    }

    .tbadge.busy {
      background: rgba(212, 120, 120, 0.18);
      color: var(--error);
    }

    .tbadge.idle {
      background: var(--bg-elevated);
      color: var(--text-muted);
    }

    .no-projects {
      color: var(--text-muted);
      font-size: 11px;
      padding: 16px 10px;
      text-align: center;
      font-style: italic;
    }

    /* Sidebar actions */
    .sidebar-actions {
      flex-shrink: 0;
      padding: 8px;
      border-top: 1px solid var(--border);
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .sidebar-btn {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
      padding: 7px 10px;
      border-radius: 6px;
      font-size: 11px;
      font-family: inherit;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.15s;
      border: 1px solid;
      white-space: nowrap;
    }

    .sidebar-btn:disabled {
      opacity: 0.5;
      cursor: default;
    }

    .btn-claude {
      background: rgba(124, 179, 130, 0.1);
      border-color: rgba(124, 179, 130, 0.3);
      color: var(--success);
    }

    .btn-claude:hover:not(:disabled) {
      background: rgba(124, 179, 130, 0.18);
      border-color: var(--success);
    }

    .sidebar-btn-row {
      display: flex;
      gap: 4px;
    }
    .sidebar-btn-row .sidebar-btn {
      flex: 1;
      font-size: 11px;
      padding: 5px 6px;
    }

    .btn-gemini {
      background: rgba(239, 68, 68, 0.08);
      border-color: rgba(239, 68, 68, 0.25);
      color: #ef4444;
    }
    .btn-gemini:hover:not(:disabled) {
      background: rgba(239, 68, 68, 0.15);
      border-color: #ef4444;
    }

    .btn-codex {
      background: rgba(96, 165, 250, 0.08);
      border-color: rgba(96, 165, 250, 0.25);
      color: #60a5fa;
    }
    .btn-codex:hover:not(:disabled) {
      background: rgba(96, 165, 250, 0.15);
      border-color: #60a5fa;
    }

    .btn-new-term {
      background: var(--bg-elevated);
      border-color: var(--border);
      color: var(--text-dim);
    }

    .btn-new-term:hover:not(:disabled) {
      color: var(--text);
      border-color: var(--text-dim);
    }

    /* Sidebar overlay (mobile) */
    #sidebar-overlay {
      display: none;
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.5);
      z-index: 29;
    }

    #sidebar-overlay.visible { display: block; }

    /* Main area */
    .main-area {
      display: flex;
      flex-direction: column;
      flex: 1;
      min-width: 0;
    }

    /* Terminal tabs */
    .tabs-bar {
      display: flex;
      align-items: center;
      height: 34px;
      padding: 0 6px;
      gap: 2px;
      background: var(--bg);
      border-bottom: 1px solid var(--border);
      overflow-x: auto;
      scrollbar-width: none;
      flex-shrink: 0;
    }

    .tabs-bar::-webkit-scrollbar { display: none; }

    .tab {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 0 10px;
      height: 26px;
      font-size: 11px;
      color: var(--text-dim);
      cursor: pointer;
      border-radius: 4px;
      white-space: nowrap;
      transition: all 0.15s;
      flex-shrink: 0;
      border: 1px solid transparent;
    }

    .tab:hover {
      color: var(--text);
      background: var(--bg-elevated);
    }

    .tab.active {
      color: var(--accent);
      background: var(--accent-dim);
      border-color: rgba(201, 162, 39, 0.25);
    }

    /* Tab state indicator dot */
    .tab-state {
      width: 6px;
      height: 6px;
      border-radius: 50%;
      flex-shrink: 0;
      display: none;
    }

    .tab.state-attention .tab-state {
      display: block;
      background: var(--success);
    }

    .tab.state-busy .tab-state {
      display: block;
      background: var(--error);
      animation: tab-pulse 1.2s ease-in-out infinite;
    }

    .tab.state-plan .tab-state {
      display: block;
      background: #11a8cd;
    }

    @keyframes tab-pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.4; }
    }

    /* Tab text color when state active */
    .tab.state-attention:not(.active) { color: var(--success); }
    .tab.state-busy:not(.active) { color: var(--error); }
    .tab.state-plan:not(.active) { color: #11a8cd; }

    .tab-close {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 14px;
      height: 14px;
      font-size: 13px;
      line-height: 1;
      border-radius: 3px;
      color: var(--text-muted);
      background: none;
      border: none;
      cursor: pointer;
      padding: 0;
      font-family: inherit;
      flex-shrink: 0;
      opacity: 0;
      transition: opacity 0.1s, background 0.1s, color 0.1s;
    }

    .tab:hover .tab-close,
    .tab.active .tab-close {
      opacity: 1;
    }

    .tab-close:hover {
      background: rgba(212, 120, 120, 0.2);
      color: var(--error);
    }

    @media (pointer: coarse) {
      .tab-close { opacity: 1; }
    }

    .tab-add {
      display: flex;
      align-items: center;
      justify-content: center;
      width: 26px;
      height: 26px;
      font-size: 14px;
      color: var(--text-muted);
      cursor: pointer;
      border-radius: 4px;
      border: 1px solid transparent;
      background: none;
      font-family: inherit;
      transition: all 0.15s;
      flex-shrink: 0;
    }

    .tab-add:hover {
      color: var(--text);
      background: var(--bg-elevated);
      border-color: var(--border);
    }

    /* Terminal container */
    .terminal-wrap {
      flex: 1;
      position: relative;
      overflow-x: hidden;
      overflow-y: hidden;
      overscroll-behavior: contain;
    }

    .terminal-wrap .xterm {
      height: 100%;
      padding: 4px 0 0 4px;
      touch-action: pan-y !important;
    }

    .terminal-wrap .xterm-viewport {
      overflow-y: auto !important;
      overflow-x: hidden !important;
      -webkit-overflow-scrolling: touch;
      overscroll-behavior-y: contain;
      touch-action: pan-y !important;
      scrollbar-width: thin;
      scrollbar-color: var(--border) transparent;
    }

    .terminal-wrap .xterm-screen {
      touch-action: pan-y !important;
    }
    .terminal-wrap .xterm-viewport::-webkit-scrollbar {
      width: 8px;
    }
    .terminal-wrap .xterm-viewport::-webkit-scrollbar-track {
      background: transparent;
    }
    .terminal-wrap .xterm-viewport::-webkit-scrollbar-thumb {
      background: var(--border);
      border-radius: 4px;
    }
    .terminal-wrap .xterm-viewport::-webkit-scrollbar-thumb:hover {
      background: var(--text-dim);
    }

    /* Special keys toolbar (mobile) */
    .keys-bar {
      display: none;
      align-items: center;
      height: 36px;
      padding: 0 8px;
      gap: 4px;
      background: var(--bg-surface);
      border-top: 1px solid var(--border);
      overflow-x: auto;
      scrollbar-width: none;
      flex-shrink: 0;
    }

    .keys-bar::-webkit-scrollbar { display: none; }

    .key-btn {
      background: var(--bg-elevated);
      border: 1px solid var(--border);
      color: var(--text-dim);
      font-size: 11px;
      font-family: inherit;
      padding: 4px 10px;
      border-radius: 5px;
      cursor: pointer;
      white-space: nowrap;
      flex-shrink: 0;
      transition: all 0.15s;
    }

    .key-btn:hover, .key-btn:active {
      color: var(--text);
      border-color: var(--text-dim);
    }

    .key-btn.active {
      color: var(--accent);
      border-color: var(--accent);
      background: var(--accent-dim);
    }

    .key-btn.recording {
      color: var(--error);
      border-color: var(--error);
      background: rgba(212, 120, 120, 0.12);
      animation: mic-pulse 1.2s ease-in-out infinite;
    }

    @keyframes mic-pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }

    /* Scroll to bottom */
    .scroll-bottom {
      display: none;
      position: absolute;
      bottom: 16px;
      right: 16px;
      width: 36px;
      height: 36px;
      border-radius: 50%;
      background: var(--bg-elevated);
      border: 1px solid var(--border);
      color: var(--text-dim);
      cursor: pointer;
      align-items: center;
      justify-content: center;
      z-index: 10;
      transition: all 0.15s;
    }

    .scroll-bottom:hover {
      color: var(--text);
      border-color: var(--text-dim);
    }

    .scroll-bottom.visible { display: flex; }

    /* Floating action button (mobile) */
    .fab-actions {
      display: none;
      position: absolute;
      bottom: 60px;
      right: 16px;
      z-index: 11;
      flex-direction: column;
      align-items: flex-end;
      gap: 6px;
    }

    .fab-trigger {
      width: 36px;
      height: 36px;
      border-radius: 50%;
      background: transparent;
      border: 1px solid var(--border);
      color: var(--text-dim);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      backdrop-filter: blur(4px);
      transition: transform 0.15s, color 0.15s, border-color 0.15s;
    }

    .fab-trigger:active { transform: scale(0.92); color: var(--text); }
    .fab-trigger.open { border-color: var(--text-dim); color: var(--text); }

    .fab-menu {
      display: none;
      flex-direction: column;
      gap: 4px;
      background: var(--bg-elevated);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: 6px;
      box-shadow: 0 4px 16px rgba(0, 0, 0, 0.5);
      min-width: 160px;
    }

    .fab-menu.visible { display: flex; }

    .fab-menu-item {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 8px 12px;
      border: none;
      background: none;
      color: var(--text);
      font-family: inherit;
      font-size: 12px;
      font-weight: 500;
      border-radius: 6px;
      cursor: pointer;
      white-space: nowrap;
      transition: background 0.12s;
    }

    .fab-menu-item:active,
    .fab-menu-item:hover {
      background: var(--accent-dim);
      color: var(--accent);
    }

    .fab-menu-item svg { flex-shrink: 0; opacity: 0.7; }

    .fab-menu-item.plan-active {
      color: var(--accent);
      background: var(--accent-dim);
    }

    /* Selection overlay */
    .selection-overlay {
      position: absolute;
      inset: 0;
      z-index: 12;
      background: rgba(10, 10, 11, 0.92);
      color: var(--text);
      font-family: 'JetBrains Mono', monospace;
      white-space: pre;
      overflow: auto;
      padding: 4px 0 0 4px;
      -webkit-user-select: text;
      user-select: text;
      cursor: text;
      -webkit-overflow-scrolling: touch;
    }

    /* Toast notification */
    .fab-toast {
      position: absolute;
      bottom: 110px;
      right: 16px;
      background: var(--bg-elevated);
      border: 1px solid var(--border);
      color: var(--text);
      font-size: 11px;
      font-family: inherit;
      padding: 6px 12px;
      border-radius: var(--radius);
      z-index: 15;
      opacity: 0;
      transform: translateY(8px);
      transition: opacity 0.2s, transform 0.2s;
      pointer-events: none;
    }

    .fab-toast.visible {
      opacity: 1;
      transform: translateY(0);
    }

    /* Voice dictation preview */
    .voice-preview {
      display: none;
      flex-direction: column;
      gap: 6px;
      padding: 8px;
      background: var(--bg-elevated);
      border-top: 1px solid var(--border);
      flex-shrink: 0;
    }

    .voice-preview.visible {
      display: flex;
    }

    .voice-text {
      background: var(--bg-surface);
      border: 1px solid var(--border);
      color: var(--text);
      font-family: inherit;
      font-size: 13px;
      padding: 8px;
      border-radius: var(--radius);
      resize: none;
      line-height: 1.4;
    }

    .voice-text:focus {
      outline: none;
      border-color: var(--accent);
    }

    .voice-actions {
      display: flex;
      gap: 6px;
      justify-content: flex-end;
    }

    .voice-btn {
      font-family: inherit;
      font-size: 12px;
      font-weight: 500;
      padding: 6px 14px;
      border-radius: 6px;
      cursor: pointer;
      border: 1px solid;
      transition: all 0.15s;
    }

    .voice-cancel {
      background: none;
      border-color: var(--border);
      color: var(--text-dim);
    }

    .voice-cancel:hover {
      border-color: var(--text-dim);
      color: var(--text);
    }

    .voice-send {
      background: rgba(124, 179, 130, 0.12);
      border-color: rgba(124, 179, 130, 0.4);
      color: var(--success);
    }

    .voice-send:hover {
      background: rgba(124, 179, 130, 0.2);
      border-color: var(--success);
    }

    @media (max-width: 768px) {
      .fab-actions { display: flex; }
    }

    /* Loading screen */
    .loading-screen {
      position: absolute;
      inset: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background: var(--bg);
      z-index: 100;
      gap: 12px;
    }

    .loading-screen.hidden { display: none; }

    .loading-spinner {
      width: 32px;
      height: 32px;
      border: 3px solid var(--border);
      border-top-color: var(--accent);
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
    }

    @keyframes spin { to { transform: rotate(360deg); } }

    .loading-text {
      font-size: 13px;
      color: var(--text-dim);
    }

    .loading-error {
      font-size: 13px;
      color: var(--error);
      text-align: center;
      max-width: 320px;
      line-height: 1.5;
    }

    .loading-error a {
      color: var(--accent);
      text-decoration: none;
    }

    /* Mobile responsive */
    @media (max-width: 768px) {
      .keys-bar { display: flex; }

      #sidebar-toggle { display: flex; }
      #topbar-project { display: block; }
      #sidebar-close { display: block; }

      .sidebar {
        position: fixed;
        top: 40px;
        left: 0;
        bottom: 0;
        z-index: 30;
        width: 260px;
        transform: translateX(-100%);
        transition: transform 0.2s ease;
      }

      .sidebar.open {
        transform: translateX(0);
      }

      /* Hide font size buttons on mobile to save space */
      #btn-font-dec, #btn-font-inc { display: none; }
    }

    @media (min-width: 769px) {
      .voice-preview { display: none !important; }
    }
  </style>
</head>
<body>
  <div class="app">
    <div class="topbar">
      <div class="topbar-left">
        <button id="sidebar-toggle" title="Toggle projects">&#9776;</button>
        <a href="/go" class="topbar-logo">PATAPIM</a>
        <span id="topbar-project"></span>
        <span class="topbar-status connecting" id="status">Connecting...</span>
      </div>
      <div class="topbar-right">
        <button class="topbar-btn" id="btn-font-dec" title="Decrease font">A-</button>
        <button class="topbar-btn" id="btn-font-inc" title="Increase font">A+</button>
        <button class="topbar-btn" id="btn-disconnect" title="Disconnect">Disconnect</button>
      </div>
    </div>

    <div id="sidebar-overlay"></div>

    <div class="content-area">
      <div class="sidebar" id="sidebar">
        <div class="sidebar-header">
          <span>Projects</span>
          <button id="sidebar-close">&times;</button>
        </div>
        <div id="projects-list">
          <div class="no-projects">Connecting...</div>
        </div>
        <div class="sidebar-actions">
          <button class="sidebar-btn btn-claude" id="btn-start-claude" disabled>
            <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><polygon points="5 3 19 12 5 21 5 3"></polygon></svg>
            Start Claude Code
          </button>
          <div class="sidebar-btn-row">
            <button class="sidebar-btn btn-gemini" id="btn-start-gemini" disabled>Start Gemini</button>
            <button class="sidebar-btn btn-codex" id="btn-start-codex" disabled>Start Codex</button>
          </div>
          <button class="sidebar-btn btn-new-term" id="btn-new-terminal" disabled>
            + New Terminal
          </button>
        </div>
      </div>

      <div class="main-area">
        <div class="tabs-bar" id="tabs"></div>

        <div class="terminal-wrap" id="terminal-wrap">
          <div class="loading-screen hidden" id="loading">
            <div class="loading-spinner"></div>
            <div class="loading-text" id="loading-text">Connecting to device...</div>
          </div>
          <button class="scroll-bottom" id="scroll-bottom" title="Scroll to bottom">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <polyline points="6 9 12 15 18 9"></polyline>
            </svg>
          </button>

          <!-- Floating action button group -->
          <div class="fab-actions" id="fab-actions">
            <div class="fab-menu" id="fab-menu">
              <button class="fab-menu-item" id="fab-plan-mode">
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                  <path d="M12 2L2 7l10 5 10-5-10-5z"/>
                  <path d="M2 17l10 5 10-5"/>
                  <path d="M2 12l10 5 10-5"/>
                </svg>
                <span>Toggle Plan Mode</span>
              </button>
              <button class="fab-menu-item" id="fab-skip-perms">
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                  <polygon points="5 3 19 12 5 21 5 3"/>
                </svg>
                Start Claude (skip perms)
              </button>
              <button class="fab-menu-item" id="fab-paste">
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                  <path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"/>
                  <rect x="8" y="2" width="8" height="4" rx="1" ry="1"/>
                </svg>
                Paste from clipboard
              </button>
              <button class="fab-menu-item" id="fab-image">
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                  <rect x="3" y="3" width="18" height="18" rx="2" ry="2"/>
                  <circle cx="8.5" cy="8.5" r="1.5"/>
                  <polyline points="21 15 16 10 5 21"/>
                </svg>
                Insert image file
              </button>
            </div>
            <button class="fab-trigger" id="fab-trigger" title="Actions">
              <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                <line x1="12" y1="5" x2="12" y2="19"></line>
                <line x1="5" y1="12" x2="19" y2="12"></line>
              </svg>
            </button>
          </div>

          <div class="fab-toast" id="fab-toast"></div>
          <input type="file" id="image-picker" accept="image/*" style="display:none" />
        </div>

        <!-- Voice dictation preview -->
        <div class="voice-preview" id="voice-preview">
          <textarea class="voice-text" id="voice-text" rows="3" placeholder="Habla ahora..."></textarea>
          <div class="voice-actions">
            <button class="voice-btn voice-cancel" id="voice-cancel">âœ• Cancelar</button>
            <button class="voice-btn voice-send" id="voice-send">â†µ Enviar</button>
          </div>
        </div>
        <div class="keys-bar" id="keys-bar">
          <button class="key-btn" data-modifier="ctrl">Ctrl</button>
          <button class="key-btn" data-modifier="alt">Alt</button>
          <button class="key-btn" data-key="Tab">Tab</button>
          <button class="key-btn" id="key-shift-tab">â‡§Tab</button>
          <button class="key-btn" data-key="Escape">Esc</button>
          <button class="key-btn" data-key="ArrowUp">&uarr;</button>
          <button class="key-btn" data-key="ArrowDown">&darr;</button>
          <button class="key-btn" data-key="ArrowLeft">&larr;</button>
          <button class="key-btn" data-key="ArrowRight">&rarr;</button>
          <button class="key-btn" data-seq="\x01">^A</button>
          <button class="key-btn" data-seq="\x03">^C</button>
          <button class="key-btn" data-seq="\x04">^D</button>
          <button class="key-btn" data-seq="\x0c">^L</button>
          <button class="key-btn" data-seq="\x1a">^Z</button>
          <button class="key-btn" id="key-mic" title="Dictado por voz">ðŸŽ¤</button>
          <button class="key-btn" id="key-select" style="margin-left:auto; border-color:var(--accent); color:var(--accent);">Select</button>
        </div>
      </div>
    </div>
  </div>

  <script is:inline type="module">
    import { Terminal } from 'https://cdn.jsdelivr.net/npm/@xterm/xterm@5.5.0/+esm';
    import { FitAddon } from 'https://cdn.jsdelivr.net/npm/@xterm/addon-fit@0.10.0/+esm';

    // Parse URL params
    const params = new URLSearchParams(location.search);
    const deviceToken = params.get('d');

    // Active connection variables (mutable â€” refreshed on reconnect)
    let activeConnectToken = params.get('t');
    let activeTunnelUrl = params.get('url');
    let activeDeviceToken = deviceToken;

    // DOM
    const statusEl = document.getElementById('status');
    const tabsEl = document.getElementById('tabs');
    const loadingEl = document.getElementById('loading');
    const loadingText = document.getElementById('loading-text');
    const terminalWrap = document.getElementById('terminal-wrap');
    const scrollBottomBtn = document.getElementById('scroll-bottom');
    const sidebarEl = document.getElementById('sidebar');
    const sidebarOverlay = document.getElementById('sidebar-overlay');
    const sidebarToggle = document.getElementById('sidebar-toggle');
    const sidebarClose = document.getElementById('sidebar-close');
    const projectsList = document.getElementById('projects-list');
    const topbarProject = document.getElementById('topbar-project');
    const btnStartClaude = document.getElementById('btn-start-claude');
    const btnStartGemini = document.getElementById('btn-start-gemini');
    const btnStartCodex = document.getElementById('btn-start-codex');
    const btnNewTerminal = document.getElementById('btn-new-terminal');
    const fabTrigger = document.getElementById('fab-trigger');
    const fabMenu = document.getElementById('fab-menu');
    const fabPlanMode = document.getElementById('fab-plan-mode');
    const fabSkipPerms = document.getElementById('fab-skip-perms');
    const fabPaste = document.getElementById('fab-paste');
    const fabImage = document.getElementById('fab-image');
    const fabToast = document.getElementById('fab-toast');
    const imagePicker = document.getElementById('image-picker');
    const keySelect = document.getElementById('key-select');
    const keyShiftTab = document.getElementById('key-shift-tab');
    const keyMic = document.getElementById('key-mic');
    const voicePreview = document.getElementById('voice-preview');
    const voiceText = document.getElementById('voice-text');
    const voiceSend = document.getElementById('voice-send');
    const voiceCancel = document.getElementById('voice-cancel');

    // State
    let ws = null;
    let term = null;
    let fitAddon = null;
    let currentTerminalId = null;
    let terminals = [];
    let isSwitching = false;
    let switchOutputQueue = [];
    let ptyDims = null;
    let isApplyingServerResize = false;
    let lastSentResize = { terminalId: null, cols: 0, rows: 0 };
    let lastFocusSync = { terminalId: null, focused: null };
    let lastVisualViewportHeight = 0;
    let fontSize = 14;
    let reconnectAttempts = 0;
    let reconnectTimer = null;
    let isAuthenticated = false;
    const modifiers = { ctrl: false, alt: false };
    let fabOpen = false;
    let isPlanMode = false;
    let selectMode = false;
    let recognition = null;
    let isRecording = false;
    let voiceFinalText = '';
    let selectionOverlay = null;
    let mobileKeyboardOpen = false;

    function detectMobileClient() {
      if (navigator.userAgentData && typeof navigator.userAgentData.mobile === 'boolean') {
        return navigator.userAgentData.mobile;
      }
      const userAgent = navigator.userAgent || '';
      const uaMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini|Mobile/i.test(userAgent);
      const coarsePointer = window.matchMedia('(pointer: coarse)').matches;
      const narrowViewport = window.matchMedia('(max-width: 1024px)').matches;
      return uaMobile || (coarsePointer && narrowViewport);
    }

    const isMobileClient = detectMobileClient();

    // Sidebar state
    let sidebarData = { projects: [], currentProject: null };

    // Helper to fetch a fresh connectToken from the server
    async function fetchConnectToken(devToken) {
      const res = await fetch('/api/device/connect-token', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        credentials: 'same-origin',
        body: JSON.stringify({ deviceToken: devToken }),
      });
      if (res.status === 401) return { error: 'session_expired' };
      if (!res.ok) return { error: 'fetch_failed' };
      return res.json();
    }

    // Init: connect from URL params or auto-reconnect from localStorage
    if (activeConnectToken && activeTunnelUrl) {
      // Normal flow from dashboard â€” store deviceToken for future reconnects
      if (activeDeviceToken) {
        localStorage.setItem('patapim_device', JSON.stringify({
          deviceToken: activeDeviceToken, ts: Date.now()
        }));
      }
      initTerminal();
      connect();
    } else {
      // Try auto-reconnect from localStorage
      tryAutoReconnect();
    }

    async function tryAutoReconnect() {
      const stored = JSON.parse(localStorage.getItem('patapim_device') || 'null');
      if (!stored?.deviceToken) {
        showError('Missing connection parameters. <a href="/go">Go back to dashboard</a>');
        return;
      }
      loadingText && (loadingText.textContent = 'Reconnecting...');
      const result = await fetchConnectToken(stored.deviceToken);
      if (result.error === 'session_expired') {
        localStorage.removeItem('patapim_device');
        window.location.href = '/go';
        return;
      }
      if (!result.connectToken || !result.tunnelUrl) {
        showError((result.error || 'Device offline') + '. <a href="/go">Go back to dashboard</a>');
        return;
      }
      activeConnectToken = result.connectToken;
      activeTunnelUrl = result.tunnelUrl;
      activeDeviceToken = stored.deviceToken;
      initTerminal();
      connect();
    }

    function showError(html) {
      loadingEl.classList.remove('hidden');
      loadingText.remove();
      const spinner = loadingEl.querySelector('.loading-spinner');
      if (spinner) spinner.remove();
      const err = document.createElement('div');
      err.className = 'loading-error';
      err.innerHTML = html;
      loadingEl.appendChild(err);
    }

    function setStatus(state, text) {
      statusEl.textContent = text;
      statusEl.className = 'topbar-status ' + state;
    }

    function isMobileResizeMode() {
      const coarsePointer = window.matchMedia('(pointer: coarse)').matches;
      const narrowViewport = window.matchMedia('(max-width: 1024px)').matches;
      const hasTouch = typeof navigator.maxTouchPoints === 'number' && navigator.maxTouchPoints > 0;
      return isMobileClient || (coarsePointer && narrowViewport) || (hasTouch && narrowViewport);
    }

    function getVisualViewportWidthRatio() {
      const vp = window.visualViewport;
      if (!vp) return 1;

      const visualWidth = Math.round(Number(vp.width) || 0);
      const layoutWidth = Math.round(Number(window.innerWidth || document.documentElement.clientWidth) || 0);
      if (!visualWidth || !layoutWidth || visualWidth >= layoutWidth) {
        return 1;
      }

      const ratio = visualWidth / layoutWidth;
      return Number.isFinite(ratio) && ratio > 0 ? ratio : 1;
    }

    // Apply terminal dimensions.
    // Mobile: natural cols (text wraps at screen width) + resize PTY to match.
    // Desktop: force PTY cols for correct cursor positioning.
    function applyPtyDims(options = {}) {
      if (!fitAddon || !term) return;
      const { syncServer = true, forceRefresh = false } = options;
      const isMobile = isMobileResizeMode();

      if (isMobile) {
        fitAddon.fit();

        // Some phone browsers report a desktop layout viewport.
        // Use visual viewport width ratio so cols match the actual visible area.
        const viewportRatio = getVisualViewportWidthRatio();
        if (viewportRatio < 0.99) {
          const adjustedCols = Math.max(2, Math.floor(term.cols * viewportRatio));
          if (adjustedCols > 0 && adjustedCols !== term.cols) {
            term.resize(adjustedCols, term.rows);
          }
        }

        if (forceRefresh) {
          term.refresh(0, term.rows - 1);
        }

        const cols = term.cols;
        const rows = term.rows;
        const hasRemoteDims = ptyDims && Number.isFinite(ptyDims.cols) && Number.isFinite(ptyDims.rows);
        const remoteDiffers = !hasRemoteDims || cols !== ptyDims.cols || rows !== ptyDims.rows;
        const alreadySent = lastSentResize.terminalId === currentTerminalId &&
          lastSentResize.cols === cols &&
          lastSentResize.rows === rows;

        if (syncServer &&
            !isApplyingServerResize &&
            !hasRemoteDims &&
            ws &&
            ws.readyState === WebSocket.OPEN &&
            currentTerminalId &&
            remoteDiffers &&
            !alreadySent) {
          ws.send(JSON.stringify({
            type: 'resize',
            terminalId: currentTerminalId,
            cols,
            rows,
            mobile: isMobileResizeMode(),
          }));
          lastSentResize = { terminalId: currentTerminalId, cols, rows };
        }
      } else if (ptyDims) {
        const dims = fitAddon.proposeDimensions();
        if (dims && dims.rows > 0) {
          term.resize(ptyDims.cols, dims.rows);
          if (forceRefresh) {
            term.refresh(0, term.rows - 1);
          }
        }
      } else {
        fitAddon.fit();
        if (forceRefresh) {
          term.refresh(0, term.rows - 1);
        }
      }
    }

    function scrollToBottomIfKeyboard(heightDelta) {
      if (!isMobileResizeMode() || !term) return;
      const appEl = document.querySelector('.app');
      if (heightDelta > 150) {
        // Keyboard appeared â€” iOS dvh may lag behind, so pin to visual viewport
        const vp = window.visualViewport;
        if (vp) appEl.style.height = vp.height + 'px';
        window.scrollTo(0, 0);
        requestAnimationFrame(() => {
          fitAddon.fit();
          term.scrollToBottom();
        });
      } else if (heightDelta < -150) {
        // Keyboard dismissed â€” restore dynamic viewport height and re-lock textarea
        appEl.style.height = '';
        if (isMobileClient && mobileKeyboardOpen) {
          mobileKeyboardOpen = false;
          const ta = terminalWrap?.querySelector('.xterm-helper-textarea');
          if (ta) ta.setAttribute('readonly', 'readonly');
        }
        requestAnimationFrame(() => {
          fitAddon.fit();
        });
      }
    }

    function isClientFocused() {
      return !document.hidden && document.visibilityState === 'visible';
    }

    function sendTerminalFocus(focused, terminalId = currentTerminalId) {
      if (!ws || ws.readyState !== WebSocket.OPEN || !isAuthenticated || !terminalId) return;
      const normalized = !!focused;
      if (lastFocusSync.terminalId === terminalId && lastFocusSync.focused === normalized) return;

      ws.send(JSON.stringify({
        type: 'terminal_focus',
        terminalId,
        focused: normalized,
        mobile: isMobileResizeMode(),
      }));
      lastFocusSync = { terminalId, focused: normalized };
    }

    function syncTerminalFocus(terminalId = currentTerminalId) {
      if (!terminalId) return;
      sendTerminalFocus(isClientFocused(), terminalId);
    }

    function resetTerminalView() {
      if (!term) return;
      term.clear();
      term.write('\x1b[2J\x1b[3J\x1b[H');
    }

    function debounce(fn, delay) {
      let timer = null;
      return (...args) => {
        if (timer) clearTimeout(timer);
        timer = setTimeout(() => fn(...args), delay);
      };
    }

    // â”€â”€ Plan Mode detection & toggle â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    function detectPlanMode() {
      if (!term) return false;
      const buffer = term.buffer.active;
      const start = Math.max(0, buffer.length - 15);
      let text = '';
      for (let i = start; i < buffer.length; i++) {
        const line = buffer.getLine(i);
        if (line) text += line.translateToString(false) + '\n';
      }
      return /plan\s*mode/i.test(text);
    }

    function updatePlanModeButtons() {
      isPlanMode = detectPlanMode();
      fabPlanMode.classList.toggle('plan-active', isPlanMode);
      const fabLabel = fabPlanMode.querySelector('span');
      if (fabLabel) fabLabel.textContent = isPlanMode ? 'Exit Plan Mode' : 'Toggle Plan Mode';
      keyShiftTab.classList.toggle('active', isPlanMode);
    }

    const debouncedUpdatePlanMode = debounce(updatePlanModeButtons, 500);

    function togglePlanMode() {
      if (!ws || ws.readyState !== WebSocket.OPEN || !currentTerminalId) return;

      // Send exactly one Shift+Tab â€” it's a toggle at the Claude Code level
      ws.send(JSON.stringify({ type: 'input', terminalId: currentTerminalId, data: '\x1b[Z' }));

      // Optimistically flip local state so the button responds immediately
      isPlanMode = !isPlanMode;
      fabPlanMode.classList.toggle('plan-active', isPlanMode);
      const fabLabel = fabPlanMode.querySelector('span');
      if (fabLabel) fabLabel.textContent = isPlanMode ? 'Exit Plan Mode' : 'Toggle Plan Mode';
      keyShiftTab.classList.toggle('active', isPlanMode);

      // Reconcile with actual terminal state after output arrives
      setTimeout(updatePlanModeButtons, 700);

      term.focus();
      syncTerminalFocus();
    }

    function initTerminal() {
      term = new Terminal({
        fontFamily: "'JetBrains Mono', monospace",
        fontSize,
        theme: {
          background: '#0a0a0b',
          foreground: '#e4e4e7',
          cursor: '#c9a227',
          cursorAccent: '#0a0a0b',
          selectionBackground: 'rgba(201, 162, 39, 0.3)',
          black: '#27272a',
          red: '#d47878',
          green: '#7cb382',
          yellow: '#c9a227',
          blue: '#6b9bd2',
          magenta: '#b07eb5',
          cyan: '#6bbfb8',
          white: '#e4e4e7',
          brightBlack: '#52525b',
          brightRed: '#e89090',
          brightGreen: '#96c99b',
          brightYellow: '#d4b84a',
          brightBlue: '#87b3e0',
          brightMagenta: '#c89bcb',
          brightCyan: '#88d3cd',
          brightWhite: '#fafafa',
        },
        cursorBlink: true,
        scrollback: 5000,
        allowProposedApi: true,
      });

      fitAddon = new FitAddon();
      term.loadAddon(fitAddon);
      term.open(terminalWrap);

      // On mobile, prevent the keyboard from appearing on every touch.
      // We mark the xterm textarea readonly so taps don't auto-open the keyboard;
      // our touchend handler removes readonly on quick taps to show the keyboard,
      // and we re-apply it only when the keyboard is dismissed (detected via visualViewport).
      const xtermTextarea = terminalWrap.querySelector('.xterm-helper-textarea');
      if (isMobileClient && xtermTextarea) {
        xtermTextarea.setAttribute('readonly', 'readonly');
      }

      fitAddon.fit();

      // Handle user input
      term.onData(data => {
        if (!ws || ws.readyState !== WebSocket.OPEN || !isAuthenticated) return;

        // Apply modifiers
        let sendData = data;
        if (modifiers.ctrl && data.length === 1) {
          const code = data.toUpperCase().charCodeAt(0) - 64;
          if (code > 0 && code < 32) {
            sendData = String.fromCharCode(code);
          }
          modifiers.ctrl = false;
          updateModifierButtons();
        }
        if (modifiers.alt) {
          sendData = '\x1b' + data;
          modifiers.alt = false;
          updateModifierButtons();
        }

        ws.send(JSON.stringify({
          type: 'input',
          terminalId: currentTerminalId,
          data: sendData,
        }));
      });

      const updateScrollButton = () => {
        const viewport = terminalWrap.querySelector('.xterm-viewport');
        if (!viewport) return;
        const distanceFromBottom = viewport.scrollHeight - viewport.clientHeight - viewport.scrollTop;
        const isAtBottom = distanceFromBottom < 10;
        const hasScrollback = viewport.scrollHeight > viewport.clientHeight + 10;
        scrollBottomBtn.classList.toggle('visible', !isAtBottom && hasScrollback);
      };

      // Track scroll position
      term.onScroll(updateScrollButton);
      term.onRender(() => setTimeout(updateScrollButton, 50));

      const viewport = terminalWrap.querySelector('.xterm-viewport');
      if (viewport) {
        viewport.addEventListener('scroll', debounce(updateScrollButton, 16), { passive: true });
      }

      terminalWrap.addEventListener('click', () => {
        term.focus();
        syncTerminalFocus();
      });
      // Mobile: only show keyboard on quick tap, not on hold/drag (which should scroll)
      if (isMobileClient) {
        let touchInfo = null;
        let scrollLastY = null;
        let longPressTimer = null;
        const getXtermViewport = () => terminalWrap.querySelector('.xterm-viewport');

        const cancelLongPress = () => {
          if (longPressTimer) { clearTimeout(longPressTimer); longPressTimer = null; }
        };

        terminalWrap.addEventListener('touchstart', (e) => {
          const t = e.touches[0];
          touchInfo = { x: t.clientX, y: t.clientY, time: Date.now() };
          scrollLastY = t.clientY;
          // Long-press: hold ~500ms without moving â†’ enter selection mode
          longPressTimer = setTimeout(() => {
            longPressTimer = null;
            touchInfo = null; // prevent tap-to-keyboard on touchend
            if (navigator.vibrate) navigator.vibrate(40);
            if (!selectMode) {
              selectMode = true;
              keySelect.classList.add('active');
              enterSelectionMode();
            }
          }, 500);
        }, { passive: true });

        terminalWrap.addEventListener('touchend', () => {
          cancelLongPress();
          scrollLastY = null;
          if (!touchInfo) return;
          const elapsed = Date.now() - touchInfo.time;
          if (elapsed < 300) {
            // Quick tap â€” remove readonly so the keyboard opens.
            // readonly is re-applied when the keyboard is dismissed (visualViewport resize).
            if (xtermTextarea) xtermTextarea.removeAttribute('readonly');
            mobileKeyboardOpen = true;
            term.focus();
            syncTerminalFocus();
          }
          touchInfo = null;
        });
        terminalWrap.addEventListener('touchcancel', () => {
          cancelLongPress();
          touchInfo = null;
          scrollLastY = null;
        }, { passive: true });
        terminalWrap.addEventListener('touchmove', (e) => {
          const t = e.touches[0];
          // Cancel tap/long-press if dragged
          if (touchInfo) {
            const dx = Math.abs(t.clientX - touchInfo.x);
            const dy = Math.abs(t.clientY - touchInfo.y);
            if (dx > 10 || dy > 10) {
              touchInfo = null;
              cancelLongPress();
            }
          }
          // Manually scroll xterm-viewport â€” needed because xterm-screen is a sibling of
          // xterm-viewport (not a descendant), so touch-action pan-y can't reach it natively.
          if (scrollLastY !== null) {
            const deltaY = scrollLastY - t.clientY;
            const vp = getXtermViewport();
            if (vp) vp.scrollTop += deltaY;
            scrollLastY = t.clientY;
          }
        }, { passive: true });
      } else {
        terminalWrap.addEventListener('touchstart', () => {
          term.focus();
          syncTerminalFocus();
        }, { passive: true });
      }

      // Resize delegates to applyPtyDims
      const ro = new ResizeObserver(debounce(() => {
        applyPtyDims({ forceRefresh: true });
      }, 80));
      ro.observe(terminalWrap);

      const viewportResize = debounce(() => {
        applyPtyDims({ forceRefresh: true });
      }, 80);
      window.addEventListener('resize', viewportResize);
      window.addEventListener('orientationchange', () => {
        setTimeout(() => applyPtyDims({ forceRefresh: true }), 120);
      });
      if (window.visualViewport) {
        lastVisualViewportHeight = window.visualViewport.height;

        window.visualViewport.addEventListener('resize', debounce(() => {
          const newHeight = window.visualViewport.height;
          const heightDelta = lastVisualViewportHeight - newHeight;
          lastVisualViewportHeight = newHeight;

          applyPtyDims({ forceRefresh: true });
          scrollToBottomIfKeyboard(heightDelta);
        }, 80));

        window.visualViewport.addEventListener('scroll', debounce(() => {
          // iOS pushes the page up when the keyboard opens â€” pin it back
          if (isMobileResizeMode() && window.visualViewport.offsetTop > 0) {
            window.scrollTo(0, 0);
          }
          applyPtyDims({ forceRefresh: true });
        }, 80));
      }
    }

    function connect() {
      if (!activeTunnelUrl) return;

      // Build WebSocket URL from tunnel URL
      const wsUrl = activeTunnelUrl.replace(/^https?:/, 'wss:');
      setStatus('connecting', 'Connecting...');
      loadingText && (loadingText.textContent = 'Connecting to device...');

      try {
        ws = new WebSocket(wsUrl);
      } catch (e) {
        showError('Failed to connect. <a href="/go">Go back</a>');
        return;
      }

      ws.onopen = () => {
        setStatus('connecting', 'Authenticating...');
        loadingText && (loadingText.textContent = 'Authenticating...');
        reconnectAttempts = 0;
        lastFocusSync = { terminalId: null, focused: null };
        // Auth is sent after receiving 'welcome' message to avoid double-auth
      };

      ws.onmessage = (e) => {
        try {
          handleMessage(JSON.parse(e.data));
        } catch (err) {
          console.error('[WS] Parse error:', err);
        }
      };

      ws.onclose = () => {
        setStatus('disconnected', 'Disconnected');
        enableActions(false);
        lastFocusSync = { terminalId: null, focused: null };
        // Reset switch state so output isn't queued forever on reconnect
        isSwitching = false;
        switchOutputQueue = [];
        if (isAuthenticated && reconnectAttempts < 10 && activeDeviceToken) {
          reconnectTimer = setTimeout(async () => {
            reconnectAttempts++;
            setStatus('connecting', 'Reconnecting...');
            const result = await fetchConnectToken(activeDeviceToken);
            if (result.connectToken && result.tunnelUrl) {
              activeConnectToken = result.connectToken;
              activeTunnelUrl = result.tunnelUrl;
              connect();
            }
          }, 2000);
        }
      };

      ws.onerror = () => {
        setStatus('disconnected', 'Connection error');
      };
    }

    function handleMessage(msg) {
      switch (msg.type) {
        case 'welcome':
          // Server sent welcome, now authenticate with connect token
          ws.send(JSON.stringify({
            type: 'auth',
            connectToken: activeConnectToken,
          }));
          break;

        case 'auth_result':
          if (msg.success) {
            isAuthenticated = true;
            setStatus('connected', 'Connected');
            loadingEl.classList.add('hidden');
            enableActions(true);

            // Clear all URL params to prevent token reuse on refresh
            history.replaceState(null, '', '/remote');

            // Don't render tabs from auth_result â€” wait for sidebar_data + get_terminals
            // Request sidebar data first, which will trigger get_terminals with correct project
            ws.send(JSON.stringify({ type: 'get_sidebar_data' }));

            term.focus();
            syncTerminalFocus();
          } else {
            showError(
              'Authentication failed: ' + (msg.error || 'Unknown error') +
              '<br><br><a href="/go">Go back to dashboard</a>'
            );
          }
          break;

        case 'output':
          if (isSwitching) {
            switchOutputQueue.push(msg);
            break;
          }
          if (term && msg.terminalId === currentTerminalId) {
            term.write(msg.data);
            debouncedUpdatePlanMode();
          }
          break;

        case 'pty_dimensions':
          if (currentTerminalId && msg.terminalId && msg.terminalId !== currentTerminalId) {
            break;
          }
          ptyDims = { cols: msg.cols, rows: msg.rows };
          if (msg.terminalId === currentTerminalId) {
            lastSentResize = { terminalId: msg.terminalId, cols: msg.cols, rows: msg.rows };
          }
          isApplyingServerResize = true;
          applyPtyDims({ syncServer: false });
          isApplyingServerResize = false;
          break;

        case 'terminal_init':
          if (term && msg.terminalId === currentTerminalId) {
            if (msg.cols && msg.rows) {
              ptyDims = { cols: msg.cols, rows: msg.rows };
              lastSentResize = { terminalId: msg.terminalId, cols: msg.cols, rows: msg.rows };
              isApplyingServerResize = true;
              applyPtyDims({ syncServer: false });
              isApplyingServerResize = false;
            }
            resetTerminalView();
            if (msg.data) {
              term.write(msg.data);
            }
            applyPtyDims({ syncServer: true, forceRefresh: true });
            updatePlanModeButtons();
            // Drain any output queued during a project switch
            if (isSwitching) {
              const queue = switchOutputQueue;
              switchOutputQueue = [];
              isSwitching = false;
              for (const q of queue) {
                if (q.terminalId === currentTerminalId && q.data) {
                  term.write(q.data);
                }
              }
            }
          }
          break;

        case 'terminals':
        case 'switched':
          if (msg.terminals) {
            terminals = msg.terminals;
            renderTabs();
          }
          if (msg.currentTerminal || msg.terminalId) {
            const previousTerminalId = currentTerminalId;
            const newId = msg.currentTerminal || msg.terminalId;
            if (newId !== currentTerminalId && term) {
              ptyDims = null;
              lastSentResize = { terminalId: null, cols: 0, rows: 0 };
              if (previousTerminalId) {
                sendTerminalFocus(false, previousTerminalId);
              }
              resetTerminalView();
            }
            currentTerminalId = newId;
            syncTerminalFocus(currentTerminalId);
            highlightTab(currentTerminalId);
          }
          if (msg.type === 'switched' && term) {
            resetTerminalView();
            if (msg.cols && msg.rows) {
              ptyDims = { cols: msg.cols, rows: msg.rows };
              lastSentResize = { terminalId: currentTerminalId, cols: msg.cols, rows: msg.rows };
              isApplyingServerResize = true;
              applyPtyDims({ syncServer: false });
              isApplyingServerResize = false;
            }
            if (msg.buffer) {
              term.write(msg.buffer);
            }
            applyPtyDims({ syncServer: true, forceRefresh: true });
            isSwitching = false;
            // Reset keyboard state for new terminal
            if (isMobileClient && xtermTextarea) {
              mobileKeyboardOpen = false;
              xtermTextarea.setAttribute('readonly', 'readonly');
            }
            const queue = switchOutputQueue;
            switchOutputQueue = [];
            for (const q of queue) {
              if (q.terminalId === currentTerminalId && q.data) {
                term.write(q.data);
              }
            }
            updatePlanModeButtons();
            updateScrollButton();
          }
          break;

        case 'terminal_created':
          ws.send(JSON.stringify({ type: 'get_terminals', projectPath: sidebarData.currentProject }));
          break;

        case 'terminal_closed':
          if (msg.terminalId === currentTerminalId) {
            sendTerminalFocus(false, currentTerminalId);
            currentTerminalId = null;
            ptyDims = null;
            lastSentResize = { terminalId: null, cols: 0, rows: 0 };
            lastFocusSync = { terminalId: null, focused: null };
            resetTerminalView();
          }
          ws.send(JSON.stringify({ type: 'get_terminals', projectPath: sidebarData.currentProject }));
          break;

        case 'sidebar_data':
          sidebarData.projects = msg.projects || [];
          sidebarData.currentProject = msg.currentProject || null;
          renderProjects();
          updateTopbarProject();
          // Fetch terminals with explicit project filter
          ws.send(JSON.stringify({ type: 'get_terminals', projectPath: sidebarData.currentProject }));
          break;

        case 'command_response':
          if (msg.success) {
            // Re-fetch terminals after successful command
            ws.send(JSON.stringify({ type: 'get_terminals', projectPath: sidebarData.currentProject }));
            ws.send(JSON.stringify({ type: 'get_sidebar_data' }));
          }
          break;

        case 'pong':
          break;
      }
    }

    // -- Sidebar: projects --

    function renderProjects() {
      projectsList.innerHTML = '';

      // Filter out archived, sort by lastOpenedAt
      const projects = (sidebarData.projects || [])
        .filter(p => !p.archived)
        .sort((a, b) => {
          const ta = a.lastOpenedAt || a.addedAt || '';
          const tb = b.lastOpenedAt || b.addedAt || '';
          return tb.localeCompare(ta);
        });

      if (projects.length === 0) {
        const empty = document.createElement('div');
        empty.className = 'no-projects';
        empty.textContent = 'No projects found';
        projectsList.appendChild(empty);
        return;
      }

      projects.forEach(p => {
        const item = document.createElement('div');
        item.className = 'project-item' + (p.path === sidebarData.currentProject ? ' active' : '');
        item.dataset.path = p.path;

        const icon = document.createElement('span');
        icon.className = 'project-icon';
        icon.textContent = '\uD83D\uDCC1';
        item.appendChild(icon);

        const name = document.createElement('span');
        name.className = 'project-name';
        name.textContent = p.path.split(/[/\\]/).filter(Boolean).pop() || p.path;
        name.title = p.path;
        item.appendChild(name);

        // Terminal count badges (attention=green/done, busy=red/processing, idle=grey)
        const counts = p.terminalCounts;
        if (counts && (counts.attention > 0 || counts.busy > 0 || counts.idle > 0)) {
          const badges = document.createElement('div');
          badges.className = 'project-badges';

          if (counts.attention > 0) {
            const b = document.createElement('span');
            b.className = 'tbadge attention';
            b.textContent = counts.attention;
            b.title = counts.attention + ' finished';
            badges.appendChild(b);
          }
          if (counts.busy > 0) {
            const b = document.createElement('span');
            b.className = 'tbadge busy';
            b.textContent = counts.busy;
            b.title = counts.busy + ' processing';
            badges.appendChild(b);
          }
          if (counts.idle > 0) {
            const b = document.createElement('span');
            b.className = 'tbadge idle';
            b.textContent = counts.idle;
            b.title = counts.idle + ' idle';
            badges.appendChild(b);
          }

          item.appendChild(badges);
        }

        item.addEventListener('click', () => selectProject(p.path));
        projectsList.appendChild(item);
      });
    }

    function selectProject(path) {
      if (!ws || ws.readyState !== WebSocket.OPEN) return;

      sidebarData.currentProject = path;
      renderProjects();
      updateTopbarProject();

      // Queue output during the switch to prevent old terminal's output from
      // bleeding into the new project's terminal view (same pattern as switchTerminal)
      isSwitching = true;
      switchOutputQueue = [];
      resetTerminalView();

      ws.send(JSON.stringify({ type: 'select_project', path }));
      ws.send(JSON.stringify({ type: 'get_terminals', projectPath: path }));

      // Close sidebar on mobile
      closeSidebar();

      term.focus();
      syncTerminalFocus();
    }

    function updateTopbarProject() {
      if (!sidebarData.currentProject) {
        topbarProject.textContent = '';
        return;
      }
      const name = sidebarData.currentProject.split(/[/\\]/).filter(Boolean).pop();
      topbarProject.textContent = name || '';
    }

    // -- Tabs --

    function extractTerminalNumber(id) {
      const match = id && id.match(/(\d+)/);
      return match ? match[1] : '?';
    }

    function renderTabs() {
      tabsEl.innerHTML = '';
      terminals.forEach((t, i) => {
        const tab = document.createElement('div');
        const stateClass = t.needsAttention ? ' state-attention'
          : t.isProcessing ? ' state-busy'
          : t.isPlanMode ? ' state-plan'
          : '';
        tab.className = 'tab' + (t.id === currentTerminalId ? ' active' : '') + stateClass;
        tab.dataset.terminalId = t.id;

        const dot = document.createElement('span');
        dot.className = 'tab-state';
        tab.appendChild(dot);

        const label = document.createElement('span');
        label.textContent = t.name || ('Terminal ' + extractTerminalNumber(t.id));
        tab.appendChild(label);

        const closeBtn = document.createElement('button');
        closeBtn.className = 'tab-close';
        closeBtn.title = 'Close terminal';
        closeBtn.textContent = 'Ã—';
        closeBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          if (ws && ws.readyState === WebSocket.OPEN) {
            ws.send(JSON.stringify({ type: 'close_terminal', terminalId: t.id }));
          }
        });
        tab.appendChild(closeBtn);

        tab.addEventListener('click', () => switchTerminal(t.id));
        tabsEl.appendChild(tab);
      });

      // Add "+" button at end
      const addBtn = document.createElement('button');
      addBtn.className = 'tab-add';
      addBtn.textContent = '+';
      addBtn.title = 'New terminal';
      addBtn.addEventListener('click', () => {
        if (ws && ws.readyState === WebSocket.OPEN) {
          ws.send(JSON.stringify({ type: 'new_terminal' }));
        }
      });
      tabsEl.appendChild(addBtn);
    }

    function highlightTab(id) {
      tabsEl.querySelectorAll('.tab').forEach(tab => {
        tab.classList.toggle('active', tab.dataset.terminalId === id);
      });
    }

    function switchTerminal(id) {
      if (id === currentTerminalId || !ws || ws.readyState !== WebSocket.OPEN) return;
      isSwitching = true;
      switchOutputQueue = [];
      resetTerminalView();
      ws.send(JSON.stringify({ type: 'switch', terminalId: id }));
    }

    // -- Sidebar toggle (mobile) --

    function openSidebar() {
      sidebarEl.classList.add('open');
      sidebarOverlay.classList.add('visible');
    }

    function closeSidebar() {
      sidebarEl.classList.remove('open');
      sidebarOverlay.classList.remove('visible');
    }

    sidebarToggle.addEventListener('click', () => {
      if (sidebarEl.classList.contains('open')) {
        closeSidebar();
      } else {
        openSidebar();
      }
    });

    sidebarClose.addEventListener('click', closeSidebar);
    sidebarOverlay.addEventListener('click', closeSidebar);

    // -- Action buttons --

    function enableActions(enabled) {
      btnStartClaude.disabled = !enabled;
      btnStartGemini.disabled = !enabled;
      btnStartCodex.disabled = !enabled;
      btnNewTerminal.disabled = !enabled;
    }

    // Send AI command to current terminal (same as desktop startAICommand)
    function sendAICommand(command) {
      if (!ws || ws.readyState !== WebSocket.OPEN || !currentTerminalId) return;
      syncTerminalFocus();
      ws.send(JSON.stringify({ type: 'input', terminalId: currentTerminalId, data: command + '\r' }));
    }

    btnStartClaude.addEventListener('click', () => {
      sendAICommand('claude --dangerously-skip-permissions');
    });

    btnStartGemini.addEventListener('click', () => {
      sendAICommand('gemini --yolo');
    });

    btnStartCodex.addEventListener('click', () => {
      sendAICommand('codex --dangerously-bypass-approvals-and-sandbox');
    });

    btnNewTerminal.addEventListener('click', () => {
      if (!ws || ws.readyState !== WebSocket.OPEN) return;
      ws.send(JSON.stringify({ type: 'new_terminal' }));
    });

    // -- Font size controls --

    document.getElementById('btn-font-dec').addEventListener('click', () => {
      fontSize = Math.max(8, fontSize - 1);
      term.options.fontSize = fontSize;
      applyPtyDims({ forceRefresh: true });
    });

    document.getElementById('btn-font-inc').addEventListener('click', () => {
      fontSize = Math.min(28, fontSize + 1);
      term.options.fontSize = fontSize;
      applyPtyDims({ forceRefresh: true });
    });

    // Disconnect
    document.getElementById('btn-disconnect').addEventListener('click', () => {
      sendTerminalFocus(false);
      isAuthenticated = false;
      if (reconnectTimer) clearTimeout(reconnectTimer);
      if (ws) ws.close();
      location.href = '/go';
    });

    // Scroll to bottom
    scrollBottomBtn.addEventListener('click', () => {
      term.scrollToBottom();
      scrollBottomBtn.classList.remove('visible');
    });

    // Special keys bar
    document.querySelectorAll('.key-btn[data-modifier]').forEach(btn => {
      btn.addEventListener('click', () => {
        const mod = btn.dataset.modifier;
        modifiers[mod] = !modifiers[mod];
        updateModifierButtons();
        term.focus();
        syncTerminalFocus();
      });
    });

    document.querySelectorAll('.key-btn[data-key]').forEach(btn => {
      btn.addEventListener('click', () => {
        if (!ws || ws.readyState !== WebSocket.OPEN) return;
        const key = btn.dataset.key;
        const keyMap = {
          Tab: '\t',
          Escape: '\x1b',
          ArrowUp: '\x1b[A',
          ArrowDown: '\x1b[B',
          ArrowRight: '\x1b[C',
          ArrowLeft: '\x1b[D',
        };
        const data = keyMap[key] || '';
        if (data) {
          ws.send(JSON.stringify({
            type: 'input',
            terminalId: currentTerminalId,
            data,
          }));
        }
        term.focus();
        syncTerminalFocus();
      });
    });

    document.querySelectorAll('.key-btn[data-seq]').forEach(btn => {
      btn.addEventListener('click', () => {
        if (!ws || ws.readyState !== WebSocket.OPEN) return;
        ws.send(JSON.stringify({
          type: 'input',
          terminalId: currentTerminalId,
          data: btn.dataset.seq,
        }));
        term.focus();
        syncTerminalFocus();
      });
    });

    // â‡§Tab â€” smart Plan Mode toggle with state detection
    keyShiftTab.addEventListener('click', () => {
      if (!isAuthenticated) return;
      togglePlanMode();
    });

    function updateModifierButtons() {
      document.querySelectorAll('.key-btn[data-modifier]').forEach(btn => {
        const mod = btn.dataset.modifier;
        btn.classList.toggle('active', modifiers[mod]);
      });
    }

    window.addEventListener('focus', () => {
      syncTerminalFocus();
    });

    // Mobile browsers can emit transient blur events while still visible/active.
    // We only release focus on visibilitychange (hidden) to avoid losing control.

    document.addEventListener('visibilitychange', () => {
      if (document.hidden || document.visibilityState !== 'visible') {
        sendTerminalFocus(false);
      } else {
        syncTerminalFocus();
      }
    });

    // â”€â”€ FAB: toggle menu â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    function closeFab() {
      fabOpen = false;
      fabMenu.classList.remove('visible');
      fabTrigger.classList.remove('open');
    }

    fabTrigger.addEventListener('click', (e) => {
      e.stopPropagation();
      fabOpen = !fabOpen;
      fabMenu.classList.toggle('visible', fabOpen);
      fabTrigger.classList.toggle('open', fabOpen);
    });

    document.addEventListener('click', () => { if (fabOpen) closeFab(); });
    fabMenu.addEventListener('click', (e) => e.stopPropagation());

    // â”€â”€ Toast helper â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    let toastTimer = null;
    function showToast(message, duration = 2000) {
      clearTimeout(toastTimer);
      fabToast.textContent = message;
      fabToast.classList.add('visible');
      toastTimer = setTimeout(() => fabToast.classList.remove('visible'), duration);
    }

    // â”€â”€ FAB: Toggle Plan Mode (Shift+Tab with state detection) â”€â”€â”€
    fabPlanMode.addEventListener('click', () => {
      closeFab();
      if (!ws || ws.readyState !== WebSocket.OPEN || !isAuthenticated || !currentTerminalId) {
        showToast('Not connected');
        return;
      }
      togglePlanMode();
    });

    // â”€â”€ FAB: Start Claude (dangerously skip permissions) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    fabSkipPerms.addEventListener('click', () => {
      closeFab();
      if (!ws || ws.readyState !== WebSocket.OPEN || !currentTerminalId) {
        showToast('Not connected');
        return;
      }
      sendAICommand('claude --dangerously-skip-permissions');
    });

    // â”€â”€ FAB: Paste from clipboard â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    fabPaste.addEventListener('click', async () => {
      closeFab();
      if (!ws || ws.readyState !== WebSocket.OPEN || !isAuthenticated || !currentTerminalId) {
        showToast('Not connected');
        return;
      }
      try {
        const text = await navigator.clipboard.readText();
        if (!text) { showToast('Clipboard is empty'); return; }
        // Bracketed paste mode prevents auto-execution of multi-line pastes
        const data = '\x1b[200~' + text + '\x1b[201~';
        ws.send(JSON.stringify({ type: 'input', terminalId: currentTerminalId, data }));
        showToast('Pasted ' + text.length + ' chars');
      } catch (err) {
        showToast('Clipboard access denied');
        console.warn('[FAB] Clipboard read failed:', err);
      }
      term.focus();
      syncTerminalFocus();
    });

    // â”€â”€ FAB: Insert image â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    fabImage.addEventListener('click', () => {
      closeFab();
      if (!ws || ws.readyState !== WebSocket.OPEN || !isAuthenticated || !currentTerminalId) {
        showToast('Not connected');
        return;
      }
      imagePicker.click();
    });

    imagePicker.addEventListener('change', () => {
      const file = imagePicker.files[0];
      if (!file) return;
      if (file.size > 10 * 1024 * 1024) {
        showToast('Image too large (max 10 MB)');
        imagePicker.value = '';
        return;
      }
      const reader = new FileReader();
      reader.onload = () => {
        const base64 = reader.result.split(',')[1];
        ws.send(JSON.stringify({
          type: 'file_upload',
          terminalId: currentTerminalId,
          fileName: file.name,
          mimeType: file.type,
          size: file.size,
          data: base64,
        }));
        showToast('Sent: ' + file.name);
        term.focus();
        syncTerminalFocus();
      };
      reader.onerror = () => showToast('Failed to read file');
      reader.readAsDataURL(file);
      imagePicker.value = '';
    });

    // â”€â”€ Voice dictation (Web Speech API) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    function initSpeechRecognition() {
      const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
      if (!SR) return null;

      const r = new SR();
      r.lang = navigator.language || 'es-ES';
      r.interimResults = true;
      r.continuous = false;
      r.maxAlternatives = 1;

      r.onresult = (e) => {
        let interim = '';
        let final = '';
        for (let i = e.resultIndex; i < e.results.length; i++) {
          const t = e.results[i][0].transcript;
          if (e.results[i].isFinal) final += t;
          else interim += t;
        }
        voiceFinalText = final || interim;
        voiceText.value = voiceFinalText;
      };

      r.onend = () => {
        stopRecording();
        if (voiceFinalText.trim()) {
          showVoicePreview();
        } else {
          showToast('No se detectÃ³ audio');
        }
      };

      r.onerror = (e) => {
        stopRecording();
        if (e.error === 'not-allowed') showToast('Permiso de micrÃ³fono denegado');
        else if (e.error === 'no-speech') showToast('No se detectÃ³ audio');
        else showToast('Error de voz: ' + e.error);
      };

      return r;
    }

    function startRecording() {
      const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
      if (!SR) {
        showToast('Tu navegador no soporta dictado por voz');
        return;
      }
      voiceFinalText = '';
      voiceText.value = '';
      recognition = initSpeechRecognition();
      if (!recognition) return;
      try {
        recognition.start();
        isRecording = true;
        keyMic.classList.add('recording');
      } catch (e) {
        showToast('Error al iniciar el micrÃ³fono');
      }
    }

    function stopRecording() {
      isRecording = false;
      keyMic.classList.remove('recording');
      if (recognition) {
        try { recognition.stop(); } catch (_) {}
        recognition = null;
      }
    }

    function showVoicePreview() {
      voicePreview.classList.add('visible');
      voiceText.focus();
    }

    function hideVoicePreview() {
      voicePreview.classList.remove('visible');
      voiceFinalText = '';
      voiceText.value = '';
    }

    // Mic button: toggle recording
    keyMic.addEventListener('click', () => {
      if (!isAuthenticated) return;
      if (isRecording) {
        if (recognition) recognition.stop();
      } else {
        startRecording();
      }
    });

    // Send: write transcribed text to terminal â€” user decides Enter
    voiceSend.addEventListener('click', () => {
      const text = voiceText.value.trim();
      if (text && ws && ws.readyState === WebSocket.OPEN && currentTerminalId) {
        ws.send(JSON.stringify({ type: 'input', terminalId: currentTerminalId, data: text }));
      }
      hideVoicePreview();
      term.focus();
      syncTerminalFocus();
    });

    // Cancel: discard
    voiceCancel.addEventListener('click', () => {
      if (isRecording) stopRecording();
      hideVoicePreview();
    });

    // â”€â”€ Text selection mode â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    keySelect.addEventListener('click', () => {
      selectMode = !selectMode;
      keySelect.classList.toggle('active', selectMode);
      if (selectMode) enterSelectionMode();
      else exitSelectionMode();
    });

    function enterSelectionMode() {
      if (selectionOverlay) return;
      const buffer = term.buffer.active;
      let text = '';
      for (let i = 0; i < buffer.length; i++) {
        const line = buffer.getLine(i);
        if (line) text += line.translateToString(true) + '\n';
      }
      selectionOverlay = document.createElement('div');
      selectionOverlay.className = 'selection-overlay';
      selectionOverlay.textContent = text;
      selectionOverlay.style.fontSize = fontSize + 'px';
      terminalWrap.appendChild(selectionOverlay);
      // Scroll to bottom to match terminal viewport
      selectionOverlay.scrollTop = selectionOverlay.scrollHeight;
      keySelect.textContent = 'Done';
    }

    function exitSelectionMode() {
      const selection = window.getSelection();
      if (selection && selection.toString().trim()) {
        navigator.clipboard.writeText(selection.toString()).then(() => {
          showToast('Copied to clipboard');
        }).catch(() => {});
      }
      if (selectionOverlay) {
        selectionOverlay.remove();
        selectionOverlay = null;
      }
      keySelect.textContent = 'Select';
      keySelect.classList.remove('active');
      selectMode = false;
      term.focus();
      syncTerminalFocus();
    }

    // Keepalive ping
    setInterval(() => {
      if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({ type: 'ping' }));
      }
    }, 30000);
  </script>
</body>
</html>
